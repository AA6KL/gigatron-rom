
{-----------------------------------------------------------------------+
|                                                                       |
|       CardTest                                                        |
|                                                                       |
|       !!! Work in progress !!!                                        |
|                                                                       |
|       The goal is to connect to a FAT32-formatted SD/MCC card         |
|       over the SPI interface, and then list its root directory.       |
|                                                                       |
+-----------------------------------------------------------------------}

{

  https://cdn.hackaday.io/images/1744261554112919559.png
  XXX  Byte addressing for V2 cards when CCS bit in OCR of CMD58 is 0
  XXX  MMC v3 card detection with CMD1
  XXX  Don't set block size with CMD16 if CCS bit in OCS is 1
  XXX  Figure out why Apple formats card with type 0x0b
  XXX  List all entries in root dir
        --------------------------
        >DIR
        Volume GIGATRON-1
        720327 <DIR> MARCELK
        190910 <DIR> APPS
        190910  1810 SNAKE.GT1
        190910 16232 FILENAME.EXT
        190910  1212 README.TXT
        190910 131072 BIGFILE.ROM
        >
        --------------------------

  XXX  Implement filesize/EOF
  XXX  Implement ReadNextSector with FAT
  XXX  Transfer 256 bytes at once
  XXX  Verify 16-bit checksum
}

{
  References:

        http://www.dejazzer.com/ee379/lecture_notes/lec12_sd_card.pdf
        SPI and SD cards

        https://electronics.stackexchange.com/questions/303745/sd-card-initialization-problem-cmd8-wrong-response
        SD card initialization problem - CMD8 wrong response

        http://www.rjhcoding.com/avrc-sd-interface-1.php
        http://www.rjhcoding.com/avrc-sd-interface-2.php
        http://www.rjhcoding.com/avrc-sd-interface-3.php
        http://www.rjhcoding.com/avrc-sd-interface-4.php
        Interfacing an SD Card Part 1-4

        https://www.pjrc.com/tech/8051/ide/fat32.html
        Understanding FAT32 Filesystems
}

gcl0x

{-----------------------------------------------------------------------+
|                                                                       |
|       Variables                                                       |
|                                                                       |
+-----------------------------------------------------------------------}

{
        Variable                Description
        --------                -----------
        CardType                Detected card version
        Address                 RAM for transfer buffer
        ValueL,H                32-bit accumulator
        OffsetL,H               Offset to be added to ValueL,H
        SectorL,H               Block number of last sector (if FAT32)
        RootDirL,H              Begin cluster of FAT32 root directory

        ClusterSize             Sectors per cluster: 1, 2, ... 128
        ClusterBaseL,H          Cluster 0 (hypothetical)
        FatSizeL,H              Sectors per FAT
        FatBaseL,H              XXX
}

{-----------------------------------------------------------------------+
|                       RAM page 2                                      |
+-----------------------------------------------------------------------}

\romType, \romTypeValue_ROMv4-  {Version check >= ROMv4}
[if<0 do _frameCount _vPCH: loop]

{-----------------------------------------------------------------------+
|                                                                       |
|       Memory card section                                             |
|                                                                       |
+-----------------------------------------------------------------------}

$500 Address=                   {Memory address for data exchange}

{ CMD0: GO_IDLE_STATE }
[def
  {
    Resets the SD Memory Card
  }
  push
  [def `CMD0`` #0] PrintText!

  0 CardType=

  {
  |  """To communicate with the SD card, your program has to place the SD
  |     card into the SPI mode. To do this, set the MOSI and CS lines to
  |     logic value 1 and toggle SD CLK for at least 74 cycles."""
  }

  10 [do i=                     {Lets do 10 bytes for 80 cycles}
    SendOnesToCard!             {Keep MOSI line high by only sending ones}
    i 1- if>0loop]

  {
  |  """After the 74 cycles (or more) have occurred, your program
  |     should set the CS line to 0 and send the command CMD0:
  |         01.000000 00000000 00000000 00000000 00000000 1001010.1
  |     This is the reset command, which puts the SD card into the SPI
  |     mode if executed when the CS line is low."""
  }

  EnableCard!                   {Sets /SS0 to 0}
  [def #$40 #0 #0 #0 #0 #$95]   {CMD0 Reset}
  SendCommandToCard!

  {
  |  """The SD card will respond to the reset command by sending a basic
  |     8-bit response on the MISO line. The structure of this response is
  |     shown in Fig.6. The first bit is always a 0, while the other bits
  |     specify any errors that may have occured when processing the last
  |     message. If the command you sent was successfully received, then
  |     you will receive the message (00000001)_2.
  |
  |         7   6   5   4   3   2   1   0
  |       +---+---+---+---+---+---+---+---+
  |       | 0 |   |   |   |   |   |   |   |
  |       +---+---+---+---+---+---+---+---+
  |             ^   ^   ^   ^   ^   ^   ^
  |             |   |   |   |   |   |   `--------in idle state
  |             |   |   |   |   |   `------------erase state
  |             |   |   |   |   `----------------illegal command
  |             |   |   |   `--------------------CRC error
  |             |   |   `------------------------erase sequence error
  |             |   `----------------------------address error
  |             `--------------------------------parameter error
  |     Figure 6 Format of a basic 8-bit Response to every command in SPI mode"""
  }

  WaitForCardReply!
  1^ PrintResult!               {Only 1 means success}

  pop ret
] CMD0=

{ CMD8: SEND_IF_COND }
[def
  {
    Send interface condition
  }
  push
  [def `CMD8`` #0] PrintText!

  {
  |  """Following a successful reset, test if your system can successfully
  |     communicate with the SD card by sending a different command. For
  |     example, send one of the following commands, while keeping the CS
  |     at value 0: (i) Command CMD8
  |             01.001000 00000000 00000000 00000001 10101010 1000011.1
  |                                       (Fixed CRC -marcelk ^^^^^^^)
  |
  |     This command is only available in the latest cards, compatible with
  |     SD card Specifications version 2.0. For most older cards this command
  |     should fail and cause the SD card to respond with a message that
  |     this command is illegal.
  |     (ii) Command CMD58
  |             01.111010 00000000 00000000 00000000 00000000 0111010.1
  |     This command requests the contents of the operating conditions
  |     register for the connected card.
  |
  |     A response to these commands consists of 40 bits (see Fig.7), where
  |     the first 8 bits are identical to the basic 8-bit response, while
  |     the remaining 32 bits contain specific information about the SD
  |     card. Although the actual contents of the remaining 32 bits are not
  |     important for this discussion, a valid response indicates that your
  |     command was transmitted and processed successfully. If successful,
  |     the first 8 bits of the response will be either 00000001 or 00000101
  |     depending on the version of your SD card.
  |
  |    39 38 37 36 35 34 33 32 31...28 27 .. 12 11 .. 8 7    ..     0
  |   +--+--+--+--+--+--+--+--+-------+--------+-------+-------------+
  |   | 0|  |  |  |  |  |  |  |Version|Reserved|Voltage|Check Pattern|
  |   +--+--+--+--+--+--+--+--+-------+--------+-------+-------------+
  |        ^  ^  ^  ^  ^  ^  ^
  |        |  |  |  |  |  |  `-----in idle state
  |        |  |  |  |  |  `--------erase state
  |        |  |  |  |  `-----------illegal command
  |        |  |  |  `--------------CRC error
  |        |  |  `-----------------erase sequence error
  |        |  `--------------------address error
  |        `-----------------------parameter error
  |   Figure 7 The format of the 40-bit Response."""
  }

  EnableCard!
  [def #$48 #0 #0 #1 #$aa #$87] {CMD8 Get Version, voltage 2.7-3.6V}
  SendCommandToCard!

  WaitForCardReply!
  $ff^ [if<>0
    CardReply 4& [if<>0
      1 CardType=               {Version 1}
    else
      SendOnesToCard!           {R7 response}
      SendOnesToCard!
      SendOnesToCard!
      SendOnesToCard!
      $aa^ [if=0                {If pattern response is correct}
        2 CardType=             {Version 2}
      ]
    ]
  ]

  CardReply 250& PrintResult!   {Return result: 0, 1, 4 or 5 means success}

  pop ret
] CMD8=

{ CMD58: READ_OCR }
[def
  push
  [def `CMD58` #0] PrintText!
  EnableCard!
  [def #$7a #0 #0 #0 #0 #0]     {CMD58}
  SendCommandToCard!
  WaitForCardReply!
  SendOnesToCard!               {R3 response}
  SendOnesToCard!
  SendOnesToCard!
  $c0& $c0^ [if=0 4 CardType=]  {CCS bit signals card is SDXC/SDHC}
  CardReply 254& PrintResult!   {Only 0 and 1 mean success}
  pop ret
] CMD58=

{ CMD55: APP_CMD }
[def
  {
    Defines to the card that the next command is an application specific
    command rather than a standard command
  }
  push
  [def `CMD55` #0] PrintText!
  [def #$77 #0 #0 #0 #0 #0]     {CMD55}
  SendCommandToCard!
  WaitForCardReply!
  254& PrintResult!             {Only 0 and 1 mean success}
  pop ret
] CMD55=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 3                                      |
+-----------------------------------------------------------------------}
*=$300

{ ACMD41 SD_SEND_OP_COND }
[def
  {
    Sends hosts capacity support information and activates the card's
    initialization process. Reserved bits shall be set to '0'
  }
  push
  [def `ACMD41 #0] PrintText!
  CardType 1^ [if=0
    [def #$69 #0 #0 #0 #0 #0]   {ACMD41 for version 1.X}
  else
    [def #$69 #$40 #0 #0 #0 #0] {ACMD41 for version 2.0+}
  ]
  SendCommandToCard!
  WaitForCardReply!
  254& PrintResult!             {Only 0 and 1 mean success}
  pop ret
] ACMD41=

{ CMD16: SET_BLOCKLEN }
[def
  {
    Set block size to 512 bytes
  }
  push
  [def `CMD16` #0] PrintText!
  [def #$50 #0 #0 #$02 #0 #0]   {CMD16}
  SendCommandToCard!
  WaitForCardReply!
  254& PrintResult!             {Only 0 and 1 mean success}
  pop ret
] CMD16=

{ CMD17: READ_SINGLE_BLOCK }
[def
  {
    Reads a block of the size selected by the SET_BLOCKLEN command
  }
  push
  {[def `CMD17` #0] PrintText!}

  [def #$51 #0 #0 #0 #0 #0]     {CMD17}
  p= q=
  >ValueH, 15& <q++ q.          {Put bit 0:27 in argument, big-endian order}
  <ValueH,     <q++ q.
  >ValueL,     <q++ q.
  <ValueL,     <q++ q.
  p SendCommandToCard!

  WaitForCardReply!
  254& {PrintResult!}           {Only 0 and 1 mean success}

  [if=0
    {Wait for first data byte}
    {[def `Wait``` #0] PrintText!}
    [do
      SendOnesToCard!           {XXX Can we use WaitForCardReply here?}
      $ff^ if=0loop]            {XXX Loop needs a timeout}
      {\sysArgs6, PrintByte!}
      {\sysArgs6, $fe^ PrintResult! {Only $fe is OK}}
  ]

  pop ret
] CMD17=

{
        Bus     ROM v4+
        ---     --------
        A0      SCLK
        A1      (unused)
        A2      /SS0
        A3      /SS1
        A4      /SS2
        A5      /SS3
        A6      B0
        A7      B1
        A8-A14  (unused)
        A15     MOSI
}

{ EnableCard }
[def
  \SYS_ExpanderControl_v4_40    {SYS function}
  _sysFn= $8078 40!             {Enable SPI0, keep MOSI high, bank=1}
  ret
] EnableCard=

{ DisableCard }
[def
  \SYS_ExpanderControl_v4_40    {SYS function}
  _sysFn= $807c 40!             {Disable SPI0, keep MOSI high, bank=1}
  ret
] DisableCard=

{ SendOnesToCard }
[def
  255 \sysArgs6.                {Place byte in exchange buffer}
  \sysArgs6 _sysArgs0=          {Begin}
  1+        _sysArgs2=          {End}
  \SYS_SpiExchangeBytes_v4_134  {SYS function}
  _sysFn= 134!                  {Exchanges a single byte}
  \sysArgs6,                    {Reply byte}
  ret
] SendOnesToCard=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 4                                      |
+-----------------------------------------------------------------------}
*=$400

{ SendCommandToCard }
[def
  push

  p= Address q=
  255 q. <q++ q. <q++           {Start with two dummy bytes}
  6 [do i=                      {Copy 6 command bytes to exchange buffer}
    p, <p++                     {Fetch byte and advance read pointer}
    q. <q++                     {Store byte and advance write pointer}
    i 1- if>0loop]              {Looping}

  { Send to SPI interface }
  Address _sysArgs0=            {Begin}
  8+      _sysArgs2=            {End and overwrite exchange buffer}
  \SYS_SpiExchangeBytes_v4_134  {SYS function}
  _sysFn= 134!

  pop ret
] SendCommandToCard=

{ WaitForCardReply }
[def
  push
  {
  |  """To receive this message, your program should continuously toggle
  |     the SD CLK signal and observe the MISO line for data, while keeping
  |     the MOSI line high and the CS line low. Your program can detect the
  |     message, because every message begins with a 0 bit, and when the
  |     SD card sends no data it keeps the MISO line high."""
  |
  |  """Note that the response to each command is sent by the card a few
  |     SD CLK cycles later. If the expected response is not received within
  |     16 clock cycles after sending the reset command, the reset command
  |     has to be sent again."""
  }
  8 [do i=                      {Poll for upto 8 reply bytes}
    SendOnesToCard!             {Keep MOSI line high by only sending ones}
    128&                        {Note: communication is byte-aligned}
    if<>0                       {Break out when valid message detected}
      i 1- if>0loop]            {Or when loop counter exhausted}

  {32 PrintChar!                 {Space}}
  \sysArgs6, CardReply=         {Store reply from card}
  {PrintByte!                    {Print hex value}}
  CardReply                     {As return value}
  pop ret
] WaitForCardReply=

[def
  push

  [do CMD0!                     {Put card in SPI mode and enable card}
    if<>0 DisableCard! loop]    {Until success} {XXX Loop needs a timeout}
  CMD8!                         {Detect version 1.X or later}
  0 _frameCount=                {Reset timer}
  [do
    CMD55! ACMD41!              {Query condition}
    CardReply if<>0             {Until the card is initialised}
    _frameCount 60- if<0loop]   {But try for no more than 1 second}
  CardType 2^ [if=0 CMD58!]     {Detect standard capacity or SDHC/SDXC}
  CMD16!                        {Set block size to 512 bytes}
  DisableCard!                  {Initialisation completed}

  pop ret
] InitCard=

{-----------------------------------------------------------------------+
|                                                                       |
|       FAT32 section                                                   |
|                                                                       |
+-----------------------------------------------------------------------}

{ ReadMBR }
[def
  {
     Checks MBR and finds the primary partition's start block
  }
  push

  0 ValueL= ValueH=
  ReadSector!                   {Read MBR}

  [def `MBR```` #0] PrintText!
  $1fe Address+ deek k=         {Check signature}
  PrintByte! >k, PrintByte!     {Print in byte order}
  $aa55 k^ PrintResult!

  pop ret
] ReadMBR=

{-----------------------------------------------------------------------+
|}$08a0 _vLR= ret{      RAM page 8                                      |
+-----------------------------------------------------------------------}
*=$8a0

{ InitFAT32 }
[def
  push
  [def `FAT32`` #0] PrintText!

  $ffff SectorH=                {Mark as invalid}

  $1c2 Address+ peek k=
  PrintByte!
  $0b k^ [if<>0 $07^]
  PrintResult!                  {Accepts $0b and $0c}
                                {XXX Check CHS or LBA ???}
  [if=0
    $1c6 Address+ deek ValueL=
    $1c8 Address+ deek ValueH=
  ]

  pop ret
] InitFAT32=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 9                                      |
+-----------------------------------------------------------------------}
*=$9a0

{ ReadVolumeID }
[def
  {
    Reads the first block of the partition. Mind that, despite it's name,
    this block doesn't hold the volume label: that is stored in the root
    directory instead.
  }
  push

  ReadSector!

  [def `Vol.ID` #0] PrintText!
  $00b Address+ deek k=         {Confirm expected sector length}
  >k, PrintByte! <k, PrintByte! {Print in word order}
  512 k^ PrintResult!

  [if=0 InitPartition!]

  pop ret
] ReadVolumeID=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 10                                     |
+-----------------------------------------------------------------------}
*=$aa0

[def
  push

  {
        ClusterBaseL,H =
                PartitionL,H                    from MBR
              + Reserved Sectors                from VolumeID
              + (Number of FATs * FAT size)     from VolumeID
              - 2 * ClusterSize                 from VolumeID
  }

  $024 Address+ deek {FatSizeL=} ValueL= OffsetL=
  $026 Address+ deek {FatSizeH=} ValueH= OffsetH=
  AddOffset!

  $00e Address+ deek OffsetL=   {Number of reserved sectors}
  0 OffsetH= AddOffset!

  $00d Address+ peek
  ClusterSize=                  {Sectors per cluster}

  0 ClusterSize- ClusterSize-   {Subtract twice for ClusterBase}
  OffsetL=
  $ffff OffsetH= AddOffset!

  SectorL OffsetL=
  SectorH OffsetH=
  AddOffset!

         ClusterBaseL=
  ValueH ClusterBaseH=

  { First cluster of root directory }
  $02c Address+ deek RootDirL=
  $02d Address+ deek RootDirH=

  pop ret
] InitPartition=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 11                                     |
+-----------------------------------------------------------------------}
*=$ba0

[def
  push

  { Sector = ClusterBase + RootDir * ClusterSize }
  RootDirL ValueL=
  RootDirH ValueH=
  ClusterToSector!
  ReadSector!

  pop ret
] ReadRootDir=

{ ReadSector }
[def
  {
    Read sector from card (clobbers ValueL,H and OffsetL,H)
  }
  push
  {PrintValue!}
  ValueL SectorL=
  ValueH SectorH=
  EnableCard!

  CardType 2- [if<0
    SectorToByte!]              {Version 1.X cards do byte addressing}
  CMD17!                        {Request block of data}

  Address q=                    {Setup write pointer}
  512 [do k=                    {Number of bytes to read}
    SendOnesToCard!             {XXX Read directly into buffer}
    q.                          {Store byte in buffer}
    q 1+ q=                     {Advance write pointer, cross page boundaries}
    k 1- if>0loop]              {Looping}

  SendOnesToCard!               {Read 16-bit checksum}
  SendOnesToCard!               {XXX We should also verify this checksum}

  DisableCard!
  pop ret
] ReadSector=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 12                                     |
+-----------------------------------------------------------------------}
*=$ca0

{ ReadNextSector }
[def
  push
  SectorL ValueL=
  SectorH ValueH=
  1 OffsetL= 0 OffsetH=
  AddOffset!
  ReadSector!
  pop ret
] ReadNextSector=

{-----------------------------------------------------------------------+
|                                                                       |
|       32-bit arithmetic section                                       |
|                                                                       |
+-----------------------------------------------------------------------}

{ SectorToByte }
[def
  {
    Multiply 32-bit ValueL,H by 512 (clobbers OffsetL,H)
  }
  push
  0        <OffsetL.           {First shift left by one byte}
  <ValueL, >OffsetL.
  >ValueL, <OffsetH.
  <ValueH, >OffsetH.

  OffsetL ValueL=              {Then double once}
  OffsetH ValueH= AddOffset!

  pop ret
] SectorToByte=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 13                                     |
+-----------------------------------------------------------------------}
*=$da0

{ ClusterToSector }
[def
  {
    Multiply ValueL,H by ClusterSize and add ClusterBase (clobbers OffsetL,H)
  }
  push
  1 [do k=
    ClusterSize- if<0
    ShiftLeft!
    k k+ loop]

  ClusterBaseL OffsetL=
  ClusterBaseH OffsetH=
  AddOffset!

  pop ret
] ClusterToSector=

{ ShiftLeft }
[def
  {
    Shift left ValueL,H by 1 bit (clobbers OffsetL,H)
  }
  push
  ValueL OffsetL=               {Double value}
  ValueH OffsetH=
  AddOffset!
  OffsetH                       {Return old high word}
  pop ret
] ShiftLeft=

{ AddOffset }
[def
  {
    Add 32-bit OffsetL,H to 32-bit ValueL,H and store result there
  }
  ValueL OffsetL^ [if<0         {Compare lower halves' most significant bits}
    ValueL                      {MSB unequal: carry taken from their sum}
  else
    $8000                       {MSB equal: carry taken from either term}
  ] OffsetL+                    {Carry now in MSB of vAC (inverted)}
  [if>=0 ValueH 1+ ValueH=]     {Apply carry to upper half}
  ValueH OffsetH+ ValueH=       {Sum upper half}
  ValueL OffsetL+ ValueL=       {Sum lower half and return this as well}
  ret
] {AddOffset=}

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 14                                     |
+-----------------------------------------------------------------------}
*=$ea0
AddOffset=

{-----------------------------------------------------------------------+
|                                                                       |
|       Video terminal section                                          |
|                                                                       |
+-----------------------------------------------------------------------}

{ SafePrintChar }
[def
  {
    Print any byte value as character, map non-ASCII to block symbol
    Insert Newline when wrapping the line
  }
  push
  32- [if<0 127 else 96-        {Map any non-ASCII to block symbol 127}
       if>=0 127] 127&
  PrintChar!                    {And print it}
  pop ret
] SafePrintChar=

{ PrintValue }
[def
  {
    Print 32-bit ValueL,H in hexadecimal
  }
  push
  ValueH PrintWord!
  ValueL PrintWord!
  Newline!
  pop ret
] PrintValue=

{ PrintWord }
[def
  {
    Print 16-bit word in hexadecimal
  }
  push
  k=
  >k, PrintByte!
  <k, PrintByte!
  pop ret
] PrintWord=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 15                                     |
+-----------------------------------------------------------------------}
*=$fa0

{ PrintByte }
[def
  {
    Print byte value in vAC as hexadecimal number
  }
  push
  2-- %0=
  4<< \vACH, PrintHexDigit!     {High nibble}
  %0 2++     PrintHexDigit!     {Low nibble}
  pop ret
] PrintByte=

{ PrintResult }
[def
  {
    Print OK or FAILED
  }
  push
  k=                            {Preserve vAC for caller}
  [if=0
    [def ``OK #10 #0]
  else
    [def ``FAILED #10 #0]
  ] PrintText!
  k
  pop ret
] PrintResult=

{ PrintHexDigit }
[def
  {
     Print lowest nibble from vAC as hex digit
  }
  push
  15&
  10- [if<0 $3a+ else $41+] PrintChar!
  pop ret
] PrintHexDigit=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 16                                     |
+-----------------------------------------------------------------------}
*=$10a0

{ PrintText -- writes q }
[def
  {
    Print text string, may include newline characters (#10)
    Returns 0
  }
  push                          {Save vLR because this is not a leaf subroutine}
  q=
  [do                           {Loop over characters}
    q, if<>0                    {Next character to be printed, unless 0}
    10^ [if<>0 10^ PrintChar!   {Print the character and advance cursor}
         else      Newline!]    {Or go to next line}
    <q++ loop]                  {Advance text pointer and loop}
  pop ret
] PrintText=

{ PrintVolumeLabel }
[def
  push

  [def `Volume` #0] PrintText!

  { Volume label 11 characters }
  p q=                          {Read pointer}
  11 [do k=                     {Loop over 12 positions}
    q, <q++                     {Print the next character}
    SafePrintChar!
    k 1- if>0loop]

  Newline!

  pop ret
] PrintVolumeLabel=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 17                                     |
+-----------------------------------------------------------------------}
*=$11a0

{ PrintTwoDecimals }
[def
  push
  Number=
  $30 k=                        {Do print leading zeroes}
  10 PrintDigit!                {Print tens}
  Number $30+ PrintChar!        {Print ones}
  pop ret
] PrintTwoDecimals=

{ PrintDate -- reads p, writes i j k q Pos _sysFn _sysArgs[01245] }
[def
  push

  \SYS_LSRW1_48 _sysFn=         {Prepare 1-bit right shift}
  p 17+ peek                    {Select year, origin is 1980}
  48! 20- [if<0 100+]
  PrintTwoDecimals!

  \SYS_LSRW5_50 _sysFn=         {Prepare 5-bit shift right}
  p 16+ deek 50! 15&            {Select month 1-12}
  PrintTwoDecimals!

  p 16+ peek 31&                {Select day 1-31}
  PrintTwoDecimals!

  pop ret
] PrintDate=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 18                                     |
+-----------------------------------------------------------------------}
*=$12a0

{ PrintDirEntry -- reads p k, writes i j k q Pos _sysFn _sysArgs[01245] }
[def
  {
    Format directory entry as "DDYYMM <size> FILENAME.EXT"
  }
  push

  { Date part of timestamp }
  PrintDate!                    {Print YYMMDD}

  { File size or directory indicator }
  PrintFileSize!

  32 PrintChar!                 {Space}

  { Filename 8.3 }
  p q=                          {Read pointer}
  11 [do k=                     {Loop over 11 positions}
    3^ [if=0
      q, 32^ if<>0              {If there is an extension}
      $2e PrintChar!]           {Period '.' before extension}
    q, <q++
    32^ [if<>0 32^              {Skip spaces (padding)}
      SafePrintChar!]           {Print the next character}
    k 1- if>0loop]

  Newline!

  pop ret
] PrintDirEntry=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 19                                     |
+-----------------------------------------------------------------------}
*=$13a0

{ PrintDigit -- reads k Value, writes i j k Number Pos _sysFn _sysArgs[01245] }
[def
  {
    Extract and print decimal digit or leading space
  }
  push
  i=                            {Radix as argument, keep in i}
  Number [do                    {Calculate Value/Radix}
    i-                          {Subtract i}
    if>=0                       {As many times as fits}
    Number=
    <k++                        {Increment 0..9 times}
    loop]
  k [if=0                       {If leading zero digit}
    32 PrintChar!               {Space}
  else
    $30| PrintChar!             {Map to $30..$39 range and print digit}
    $30 k=                      {And mark all further zeroes as non-leading}
  ]
  pop ret
] PrintDigit=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 20                                     |
+-----------------------------------------------------------------------}
*=$14a0

{ Newline -- writes i Pos _sysFn _sysArgs[01245] }
[def
                                {Clear new line first}
  $3f20 _sysArgs0=              {White on blue}
  $100 <Pos. peek >Pos. Pos     {Go to start of next line}
  _sysArgs4=                    {Set screen position}
  \sysArgs2.                    {Set all-zero output pattern}
  [do
    \SYS_VDrawBits_134          {SYS call to draw 8 pixels vertically}
    _sysFn= 134!
    <_sysArgs4++                {Step 1 pixel right}
    \sysArgs4, 160^             {Test for end of line}
    if<>0loop]
                                {Then scroll up by modifying videoTable}
  $01ee i=                      {Last entry in video table}
  [do
    i, 120- [if<0 128+
             else 8+] i.        {Rotate by 8 in 7..126 range}
    i 2- i=                     {Move to previous entry in video table}
    $fe^ if<>0loop]             {Until all done}

  ret
] Newline=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 21                                     |
+-----------------------------------------------------------------------}
*=$15a0

{ PrintChar -- reads Pos, writes i j Pos _sysFn _sysArgs[01245] }
[def
  {
    Print ASCII character (>=32) on screen using the 5x8 pixel built-in font.
    This is a bare bones version:
    1. No handling of newline characters
    2. No implicit linewrapping
    3. No blanking of the 1 pixel horizontal space between characters
  }
  82-                           {Map ASCII code to offset in font table}
  [if<0 50+ i= &_font32up       {First page for ASCII 32..81}
   else     i= &_font82up] j=   {Second page is ASCII 82..127}
  i 2<< i+                      {Multiply by 5}
  j+ j=                         {Add page address to reach bitmap data}
  $3f20 _sysArgs0=              {White on blue}
  Pos _sysArgs4=                {Position of character}
  6+ Pos=                       {Advance position by 6 pixels for next call}
  \SYS_VDrawBits_134 _sysFn=    {Prepare SYS calls}
  5 [do i=                      {Loop to draw 5 vertical slices of 8 pixels}
    j 0? \sysArgs2.             {Get byte from ROM using `LUP 0' instruction}
    134!                        {Invoke SYS function to draw 8 vertical pixels}
    <j++ <_sysArgs4++           {Advance to next slice in ROM and on screen}
    i 1- if>0loop]              {Looping}
  ret
] PrintChar=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 22                                     |
+-----------------------------------------------------------------------}
*=$16a0

{ PrintDir }
[def
  {
    Print directory contents
  }
  push
  Address [do p=                {Loop over all directory entries}
    $200 Address+ p-            {Break at end of segment}
    [if<0 ReadNextSector!
          Address loop]
    p peek if<>0                {XXX Also handle multiblock directory and EOF}
    $e5^ [if<>0                 {Skip unused entries}
      p 11+ peek k=             {Fetch attributes}
      $0f^ if<>0                {Skip long filename information}
      2& if<>0                  {Skip hidden entries}
      k 8& [if<>0
        PrintVolumeLabel!
      else
        PrintDirEntry!]
    ]
    p 32+ loop]
  pop ret
] PrintDir=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 23                                     |
+-----------------------------------------------------------------------}
*=$17a0

{ PrintFileSize }
[def
  push
  p 11+ peek 16& [if<>0
    [def ```<DIR> #0]           {Directory}
  else
    p 28+ deek ValueL=          {File size in bytes}
    p 30+ deek ValueH=
    ValueToDecimal!
    0 j=
    8 [do i=                    {Loop over no more than 9 digits}
      q, $30- if=0              {Leading zero?}
      i 6- [if<0 32 q.          {Convert last 5 into a space}
            else <j++]          {But drop the earlier zeroes}
      <q++
      i 1- if>=0loop]
    Decimal j+
  ]
  PrintText!
  pop ret
] PrintFileSize=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 24                                     |
+-----------------------------------------------------------------------}
*=$18a0

{ PrintUnsigned }
[def
  push

  Number=
  0 k=                          {Suppress leading zeroes}

  Number [if<0                  {Bring large unsigned values in range}
    -30000 Number+ Number=
    3 k=]

  10000 PrintDigit!             {Print ten thousands, largest for 16 bits}
   1000 PrintDigit!             {Print thousands}
    100 PrintDigit!             {Print hundreds}
     10 PrintDigit!             {Print tens}
    $30 Number+ PrintChar!      {Print ones}
  pop ret
] PrintUnsigned=

[def `---------- #0] Decimal=

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 25                                     |
+-----------------------------------------------------------------------}
*=$19a0

{ ValueToDecimal }
[def
  {
    Convert 32-bit ValueL,H to 10-digit decimal String
  }
  push

  9 [do i=                      {For every position i}
    Decimal i+ q= $30 q.        {Decimal[i] = '0'}
    i 1- if>=0loop]

  31 [do i=                     {For every bit}
    ShiftLeft!                  {ValueL,H <<= 1}
    [if>=0 $6a                  {No carry}
     else  $69] k=              {Carry}

    9 [do j=                    {Double the decimal result with carry}
      Decimal j+ q=             {q = &Decimal[i]}
      q, 1<< k-                 {Double next decimal with carry}
      [if<0 $3a+ q. $6a         {No carry}
       else $30+ q. $69] k=     {Carry}
      j 1- if>=0loop]

    i 1- if>=0loop]

  pop ret
] {ValueToDecimal=}

{-----------------------------------------------------------------------+
|}>_vLR++ ret{          RAM page 26                                     |
+-----------------------------------------------------------------------}
*=$1aa0
ValueToDecimal=

{-----------------------------------------------------------------------+
|                                                                       |
|       Main program                                                    |
|                                                                       |
+-----------------------------------------------------------------------}

[def #10 `***`Memory`card #10 #0] PrintText!
InitCard!

[def `CardType` #0] PrintText!
CardType PrintByte!             {Show detected card version}
Newline!

ReadMBR!                        {Master Boot Record}
InitFAT32!                      {Get FAT partition parameters}
ReadVolumeID!                   {Read first block of FAT partition}
ReadRootDir!                    {Read root directory}
PrintDir!                       {List directory}
[def `Ok #0] PrintText!
[do loop]

{-----------------------------------------------------------------------+
|                                                                       |
+-----------------------------------------------------------------------}
