
{-----------------------------------------------------------------------+
|                                                                       |
|       Recreation of Tiny BASIC for Gigatron TTL microcomputer         |
|                                                                       |
+-----------------------------------------------------------------------}

{
  2018-06-19 (marcelk) Scaffolding. Can evaluate direct print statements.
  2018-06-21 (marcelk) Can edit programs, delete lines, but no run yet
  2018-06-23 (marcelk) Can RUN, GOTO, GOSUB, RETURN and break program


  Original Tiny BASIC quirks:
    print 1+3*-8        --> Syntax error
    print 6/-2          --> Syntax error
    print -32768/2      --> 16383

  Memory allocation in Gigatron

  Zero-page:
  30 -          Tiny BASIC interpreter variables
  90 - c3       BASIC variables A..Z (XXX Might move to $0ea0?)
  c4 - ff       Stack (30 words)

  0ea0 - 07ff   Programs are stored in the invisible part of screen memory
  0ea2 - 0ebf   Input buffer (also "line 0")
  8000 - ffff   Optional memory for BASIC programs (64K extension)

  Errors:
  Break error   Program (or list command) stopped by [Del] key
  Syntax error  Parsing error. Too large program
  Value error   Calculation error (division by 0). Target line not found.
                Not raised for overflows.
  Stack error   GOSUB nesting too deep. RETURN without GOSUB.
                (XXX also too complex expressions? Or do syntax error there?)

  Todo/must have:
    IF THEN
    Relops      With correct behavior, eg -30000 < 30000
    INPUT
    PRINT       Suppress newline after ; and ,
                Allow multiple ,
    NextBlock   struct block { word nextBlock; word lineno; char[30] text;}
  Wish list:
    USR()
    PEEK() POKE
    LET         Make LET keyword optional
    Indent      Indent BASIC output 2 pixels (as in WozMon)
    Speed       Binary search for GotoValue
    LIST <n>    List one line
    Zero page:  Move variables to another page, stack space is more important
    SET x,y     Check with Had badge Move cursor
    $xx         Hexadecimal numbers
    "CHR$"      At least the ability to print an ASCII char.
    FRE()       For fun, can be implicit with LIST
    64K         Should work, but not tested. Also test out of memory errors.
    %           Modulo operator
    RND()
    ABS()
    Overflow    Errors on overflow for +, -  and *
  Maybe:
    READ, DATA  Possibly put in unused lines?
    Unary minus Original Tiny BASIC does it wrong: 8/-2
    CLS         Clear screen, move to top
    ? PR        Alias for PRINT
    AND OR NOT  At list for in IF statements
    a-z A-Z     As different variables
    @           As variable name
    '           Alias for REM
    "xxx"       String *variables*
    A()         Arrays (1-dimensional)
    @           Array as in Palo Alto Tiny BASIC (store vertically?)
  Probably not:
    :           Multiple statements in one line
    ELSE        Will slow down IF, because it has to scan for this
    FOR TO NEXT And STEP. No idea how to implement
    DEF FNx

  List of games that should be tested for compatibility:
    TicTac.bas  -> TicTac.gtb

    --------
    line ::= number statement CR | statement CR

    statement ::= PRINT expr-list
                  IF expression relop expression THEN statement
                  GOTO expression
                  INPUT var-list
                  LET var = expression
                  GOSUB expression
                  RETURN
                  CLEAR
                  LIST
                  RUN
                  END

    expr-list ::= (string|expression) (, (string|expression) )*
    var-list ::= var (, var)*
    expression ::= (+|-|empty) term ((+|-) term)*
    term ::= factor ((*|/) factor)*
    factor ::= var | number | (expression)
    var ::= A | B | C ... | Y | Z
    number ::= digit digit*
    digit ::= 0 | 1 | 2 | 3 | ... | 8 | 9
    relop ::= < (>|=|empty) | > (<|=|empty) | =
    string ::= " (a|b|c ... |x|y|z|A|B|C ... |X|Y|Z|digit)* "
    --------

  References:
        https://en.wikipedia.org/wiki/Tiny_BASIC
        Wikipedia article

        http://www.ittybittycomputers.com/IttyBitty/TinyBasic/DDJ1/Design.html
        DESIGN NOTES FOR TINY BASIC (Dennis Allison et al.)

        http://www.ittybittycomputers.com/IttyBitty/TinyBasic/
        Tom Pittman's implementation

        http://p112.sourceforge.net/tbp112.html
        P112 Tiny Basic User's Guide (V1.0, 18 FEB 1999)

        http://www.bitsavers.org/pdf/interfaceAge/197612/092-108.pdf
        Dr. Wang's Palo Alto Tiny Basic (Roger Rauskolb)

}

gcl0x

{-----------------------------------------------------------------------+
|                       RAM page 2                                      |
+-----------------------------------------------------------------------}

$01df deek Pos=                 {Bottom character row in screen memory}
                                {Slightly cheating with endianness}
$0f20 \sysArgs6:                {Pen color yellow, background color blue}
\sysArgs0.                      {First Newline call will look here}

{ Print ASCII character (32..127) on screen in 5x8 pixels }
{ Returns the actual position }
[def
  k=                            {Temporarily save character}
  Pos<, 155- [if>0              {Automatic newline BEFORE printing}
    push Newline! pop]

  k 82-                         {Map ASCII code to offset in font table}
  [if<0 50+ i= \font32up        {ASCII 32..81}
   else     i= \font82up] k=    {ASCII 82..127}
  i 2<< i+                      {Multiply by 5}
  k+ k=                         {Add to page address to reach bitmap data}

  { sysFn already set by Newline and not changed by Tiny BASIC
  \SYS_VDrawBits_134 \sysFn=    {Prepare SYS calls} }
  \sysArgs6; \sysArgs0:         {Apply caller-defined colors}
  Pos \sysArgs4=                {Position for character}
  $fe%=                         {Temporarily park return value on the stack}
  6+ Pos=                       {Advance position by 6 pixels}

  5 [do i=                      {Draw 5 vertical slices}
    k 0? \sysArgs2.             {Get slice from ROM}
    134!                        {Invoke SYS function to draw pixels}
    k<++ \sysArgs4<++           {Advance to next slice}
    i 1- if>0loop]              {Looping}

  $fe%                          {Return effective position}
  ret
] PrintChar=

{ Print inline string, returns 0 }
[def
  \vLR; tmp=                    {vLR points to inline argument}
  [do
    tmp, tmp<++                 {Grab next character}
    if<>0 PrintChar!            {Print as long as non-zero}
    loop]
  tmp!                          {Returns to caller}
] PrintS=

{ Continue printing on new line. Returns 0 }
[def
  \SYS_VDrawBits_134 \sysFn=    {Prepare SYS call}
  $800 Pos<.                    {Go back to start}
  Pos+ [if<0 $0800] Pos=        {Go down 8 lines and wrap around if needed}
  \sysArgs4=                    {sysArgs[4:5] is position on screen}
  \sysArgs2.                    {All-zero output pattern}
  [do
    134!                        {SYS call}
    \sysArgs4<++                {Advance to next slice}
    \sysArgs4, 160^             {Test for end of screen}
    if<>0loop]
                                {Scroll up by modifying videoTable}
  $01ee i=                      {Last entry in video table}
  [do
    i, 120- [if<0 128^
             else 8^]
             i.                 {Rotate by 8 in 8..127 range}
    i 2- i=                     {Previous entry in video table}
    $fe^ if<>0loop]             {Until all done}
  ret
] Newline=

{ Conditionally print leading decimal digit }
[def
  push
  i=                            {Radix as argument, keep in i}
  Value [do                     {Calculate Value/Radix}
    i-                          {Subtract i}
    if>=0                       {As many times as fits}
    Value=
    k<++                        {Increment 0..9 times}
    loop]
  k [if<>0                      {If non-zero digit or non-leading zero}
     $30| PrintChar!            {Map to $30..$39 range and print digit}
     $30 k=]                    {And mark all further zeroes as non-leading}
  pop ret
] PrintDigit=

[def
  [do Active, $20^ if=0 Active<++ loop]
  ret
] {Spaces=}

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 3                                      |
+-----------------------------------------------------------------------}
$0300:
Spaces=

[def
  Active,                       {Next character from line}
  $5f&                          {Ignore case}
  $41- {'A'} [if>=0             {Bail out if out of range}
   26- {'Z'} if<0               {Letter A..Z or a..z}
    Active<++                   {Accept character}
    26+                         {Map in 0..25 range}
    1<< $90+                    {Address is $90+2*n}
    ret                         {Return address on success}
  ]
  SyntaxError!
] TestVar=

{ Destructively print Value as signed decimal number }
[def
  push

  [if<0                         {If value is negative}
    0 Value- Value=             {Negate value}
    $2d PrintChar!]             {Print minus sign}

  0 k=                          {Suppress leading zeroes}
  10000 PrintDigit!             {Print ten thousands, largest for 16 bits}
   1000 PrintDigit!             {Print thousands}
    100 PrintDigit!             {Print hundreds}
     10 PrintDigit!             {Print tens}
    $30 Value+ PrintChar!       {Print ones}

  pop ret
] PrintValue=

{ Accept ASCII characters from console input with line editting }
[def
  push
  $a2 Buffer<.                  {Prepare for next input line}

  [do {NEXTCHAR}
    127 \sysArgs7.              {Pen color white for user input}
    PrintChar! Pos=             {Draw cursor symbol}

    \serialRaw, [do             {Wait for key change}
      tmp=                      {Remember previous value}
      \serialRaw, Buffer.       {Read new input value}
      tmp^ if=0                 {If no change}
        Buffer, loop]           {Keep waiting}

    Buffer, 10^ if<>0           {Enter/return breaks NEXTCHAR loop}

    117^ [if=0                  {Delete pressed (10^127 == 117)}
      $20 PrintChar! Pos=       {Remove cursor}
      Pos<, 6- [if>=0           {If not on first position}
        Pos<.                   {Step back}
        Buffer 1- Buffer=]      {Remove character from buffer}
      loop]                     {To NEXTCHAR}

    96- if>=0loop               {Ignore apparent unprintable garbage}

    Buffer, PrintChar!          {Print accepted characters}
    Buffer<++                   {Advance pointer, keeping the character}

    Pos<, 150^ [if=0            {Arrived at position 25 (25*6 == 150)}
      $a2 Buffer<.              {Discard of too long input}
      $5c PrintChar! Newline!]  {Overflow indicator '\'}

    loop]                       {To NEXTCHAR}

  Buffer.                       {Terminate input with zero}
  $20 PrintChar!                {Remove cursor}
  Newline!
  $0f \sysArgs7.                {Pen color yellow for output}
  $0ea2                         {Return buffer start}
  pop ret
] GetLine=

{ Parse an unsigned decimal number and put in Value }
[def
  $8000                         {Stays negative if we don't see any digits}
  [do
    Value=                      {Update partial result}
    2<< Value+ 1<< i=           {Multiply by 10 before adding decimal}

    Active,                     {Grab next character}
    $30- {'0'} if>=0            {Bail out if out of range}
    10-  {'9'} if<0             {Decimal digit}
      10+                       {Map in 0..9 range}
      i+                        {Add it to value}
      Active<++
      loop]
  Value                         {Result, negative value indicates error}
  ret
] TestNumber=

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 4                                      |
+-----------------------------------------------------------------------}
$0400:

{ Statement executor. Doesn't return through vLR }
{ Active must point to text or terminating zero, NOT to the line number }
[def
  Spaces!

  TestWord! $6c# $65# $74# 0#   {'let'}
  [if=0
    Spaces!
    TestVar!                    {Must be a variable name}
    LValue=                     {Park here}
    Spaces!
    TestWord! $3d# 0#           {'='}
    [if<>0 SyntaxError!]
    Expression!                 {Evaluate expression}
    LValue:                     {Store value in variable}
    EndOfLine!]

  TestWord! $67# $6f# $74# $6f# {'goto'}
    0#
  [if=0
    Expression!                 {Computed goto}
    GotoValue!]                 {Find that line and continue there}

  TestWord! $67# $6f# $73# $75# {'gosub'}
     $62# 0#
  [if=0
    \vSP, [if<>0                {Check stack space}
      $e0- if<=0                {XXX 16 levels is ok?}
      StackError!]              {Fail with error when too deep}
    Expression!                 {Computed gosub}
    2-- Active 0%=              {Push current line to stack}
    GotoValue!]                 {Find that line and continue there}

  TestWord! $72# $65# $74# $75# {'return'}
    $72# $6e# 0#
  [if=0
    \vSP, [if=0 StackError!]    {Top of stack}
    deek Active= 2++            {Pop line from stack}
    EndOfLine!]

  TestWord! $70# $72# $69# $6e# {'print'}
    $74# 0#
  [if=0
    [do {PRINTLIST}
      Spaces!
      Active, if<>0             {Until end of line}
      $22^                      {'"'}
      [if=0
        [do {PRINTSTRING}       {String constant}
          Active<++
          Active,
          [if=0 SyntaxError!]   {Unterminated string}
          $22^ if<>0            {'"'}
          Active, PrintChar!
          loop]                 {To PRINTSTRING}
        Active<++               {Skip past closing '"'}
      else
        Expression!
        PrintValue!]

      Active, $3b^              {';'}
      [if=0 Active<++ loop]     {To PRINTLIST}
      Active, $2c^              {','}
      [if=0
        Active<++
        [do
          $20 PrintChar!
          Pos<, 7& if<>0loop]   {Tab stops every 4 characters}
        loop]                   {To PRINTLIST}
    ]
    Newline!                    {XXX Skip this right after ; or , }
    EndOfLine!]

{
  TestWord! $69# $66# 0#        {'if'}
  [if=0                         {XXX to do}
    Expression!
    RelOp!
    Expression!
    TestWord!                   {'then'}
      $74# $68# $65# $6e# 0#
    Statement!
    EndOfLine!]
}

  TestWord! $72# $65# $6d# 0#   {'rem'}
  [if=0
    [do
      Active, if<>0             {Search for end of line}
      Active<++ loop]
    EndOfLine!]

{
  TestWord! $69# $6e# $70# $75# {'input'}
    $74# 0#
  [if=0                         {XXX to do}
    TestVar!
    EndOfLine!]
}

  StatementCont!                {Continue in another page}
] Statement=

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 5                                      |
+-----------------------------------------------------------------------}
$0500:

{ Less critical commands }
[def
  TestWord! $65# $6e# $64# 0#   {'end'}
  [if=0 Error 0#]               {XXX stop in a different way}

  TestWord! $72# $75# $6e# 0#   {'run'}
  [if=0
    $0ec0                       {First program line, if any}
    End^ [if=0 EndOfLine!]      {Don't run empty program}
    $0ec2 Active=               {Skip line number}
    Statement!]                 {And start execution}

  TestWord!                     {'list'}
    $6c# $69# $73# $74# 0#
  [if=0 List! EndOfLine!]

  TestWord! $6e# $65# $77# 0#   {'new'}
  [if=0 New! Prompt! 0#]        {Returns to prompt}

  SyntaxError!
] StatementCont=

{ Verify that there is nothing else on the line, then continue with next }
{ XXX Top heavy: speed this up by linking blocks }
[def
  Spaces!
  Active, [if<>0 SyntaxError!]  {There must be nothing left on the line}
  Active NextBlock! Active=     {Advance to next line}
  End^ [if<>0                   {Stop at end of program}
    $0ec0 Active^ if<>0         {Also stop if we came from the input buffer}
    Active 2+ Active=           {Skip past line number}
    Statement!]                 {And continue from there}
  Prompt! 0#                    {Program finished ok}
] EndOfLine=

{ Parse an inline keyword, 0 is success }
[def
  \vLR; tmp=                    {vLR points to inline argument}
  Active j=                     {Save Active in case word match fails}
  [do
    tmp, tmp<++                 {Next expected character from argument}
    if<>0                       {Compare until non-zero}
    i=
    Active,                     {Grab next character from line}
    $20|                        {Ignore case}
    i^ [if=0
      Active<++ loop            {Accept if character matches}
    else
      [do tmp, tmp<++ if<>0loop] {Eat remaining characters}
      j Active=]                {Restore BASIC pointer for next word}
  ]
  tmp!                          {Effectively returns}
] TestWord=

{ Process a full expression, result in Value and vAC }
[def
  push
                                {First term}
  Spaces!
  TestWord! $2d# 0#             {'-'}
  [if=0                         {Accept unary minus}
    Term!
    0 Value-                    {Negate}
  else
    TestWord! $2b# 0#           {'+' Ignore unary plus}
    Term!]

  2-- 0%=                       {Put partial result on stack}
  [do                           {Optional additional terms}
    Spaces!
    TestWord! $2b# 0#           {'+'}
    [if=0
       Term!
       0% Value+ 0%=            {Perform addition}
       loop]
    TestWord! $2d# 0#           {'-'}
    [if=0
       Term!
       0% Value- 0%=            {Perform subtraction}
       loop]
  ]
  0% Value= 2++                 {Make stack value the result}
  pop ret
] Expression=

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 6                                      |
+-----------------------------------------------------------------------}
$0600:

{
 Six scenarios for InsertLine          Check   Search  Shift   Copy    Shift
                                       memory  line    down    buffer  up
 1. Append a new line > last            X       -       -       X       -
 2. True insert of a new line < last    X       X       X       X       -
 3. Overwrite of existing line <= last  -       X       -       X       -
 4. Delete of existing line <= last     -       X       -       -       X
 5. Delete of non-existing line < last  X(!)    X       X(!)    -       X(!)
 6. Delete of non-existing line > last  -       -       -       -       -
}
{ Handle commands that start with a line number }
[def
  push
  TestNumber!
  [if>0
    { Lookup line number in program }
    End i= j=                   {Setup i and j for below}
    PrevBlock! deek Value-      {Retrieve last line number, 0 when no program}
    [if>=0                      {If insert/modify instead of append}
      $0ec0 [do i=              {Loop over program from beginning}
        i; Value- if<0          {Stop if found or past it}
        i NextBlock! loop]      {Advance to next line}
      if>0                      {Insert scenario}
        0; End^                 {Compare against top of memory}
        [if<>0                  {Do the copy only when safe (give error later)}
          [do                   {Copy rest of program one one slot up}
            j k= PrevBlock!     {Go up one block}
            j= tmp=
            [do                 {Copy tmp[0:31] to k[0:31]}
              tmp, k.           {Copy as bytes, don't bother with word copy}
              tmp<++ k<++       {Advance both pointers}
              tmp 31&
              if<>0loop]        {Copy all 32 bytes}

            j i^ if<>0loop]
        ]
        1                       {Non-zero to trigger advancing of End below}
    ]
    { Expand program space if needed }
    [if<>0
      0; End^                   {Compare End against top of memory}
      [if=0 SyntaxError!]       {Out of memory error if equal}
      End NextBlock! End=]      {Otherwise grab space for new line}

    Active,                     {Inspect if line has any content}
    [if<>0
      { Copy line from buffer into program }
      Value i:                  {Copy line number}
      i<++                      {Copy line text}
      [do
        i<++
        Active, Active<++       {From input buffer}
        i.                      {Into program memory}
        if<>0loop]              {Until terminating zero}
    else
      { Bare line number means delete that line }
      i j=                      {i still points at line to be deleted}
      [do
          End^ if<>0            {Until end of program}
          j NextBlock! j= tmp=  {Go down one block}
          [do                   {Copy tmp[0:31] to i[0:31]}
            tmp, i.             {Copy as bytes, don't bother with word copy}
            tmp<++ i<++         {Advance both pointers}
            tmp 31& if<>0loop]  {Copy all 32 bytes}
          j i=
          loop]
      End PrevBlock! End=       {Remove last line from program}
    ]
    Value                       {Report line number to caller}
  ]
  pop ret
] TryInsertLine=

{ Note: It is save to call functions here before hopping over to page 8 }

{ Clear program and variables, returns 0 }
[def
  $0ea0 Buffer=                 {First block in memory is input buffer}
  32+ End=                      {Programs begin 32 bytes later}

  $90 i=                        {Clear variables A-Z}
  [do
    0 i.                        {Clear byte}
    i<++                        {Advance pointer}
    i $c4^ if<>0loop]           {$90+26*2 = $c4}

  Active=                       {Not active in any line}
  Buffer:                       {Place a dummy largest line number 0 here}
  ret
] New=

{ Note: It is save to call functions here before hopping over to page 8 }

Newline!                        {Scroll and clear last line}

{ Welcome message }
PrintS!                         {'*** Tiny BASIC'}
  $2a# $2a# $2a# $20# $54# $69#
  $6e# $79# $20# $42# $41# $53#
  $49# $43# 0#

New!                            {Empty program and clear variables}

{-----------------------------------------------------------------------+
|}$08a0 \vLR= ret{      RAM page 8                                      |
+-----------------------------------------------------------------------}
$08a0:

{ Calculate address of next 32-byte block for storing BASIC lines }
{ Realign if needed }
[def
  31| 1+ tmp=                   {Advance to next 32 byte memory block}
  [if>=0                        {In the first 32K...}
    $e0& if=0                   {...wrap around visible screen memory}
      tmp 160+ ret]
  tmp
  ret
] NextBlock=

{ Go to previous block. Assume vAC already aligned to valid 32-byte block }
[def
  32- tmp=                      {Move back to previous 32 byte memory block}
  [if>=0                        {In the first 32K...}
    $60& if=0                   {...wrap around visible screen memory}
      tmp 160- ret]
  tmp
  ret
] PrevBlock=

{ Find line with line number equal to Value and go there }
[def
  TestBreak!                    {Test for [Del] as break request}
  $0ec0 [do i=                  {Loop over program from beginning}
    End^ if<>0                  {Until end of program}
    i; Value^ [if=0             {Or if matching value found}
      i 2+ Active=              {Skip past line number}
      Statement!]               {And continue from there}
    i NextBlock! loop]          {Otherwise try next line}
  ValueError!                   {Fail with error message when line not found}
] GotoValue=

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 9                                      |
+-----------------------------------------------------------------------}
$09a0:

{ Process an expression term, result in Value and vAC }
[def
  push
  Factor!                       {First factor}
  2-- Value 0%=                 {Put partial result on stack}
  [do                           {Optional additional factors}
    Spaces!
    TestWord! $2a# 0#           {'*'}
    [if=0
       Factor!
       0% Multiply! 0%=
       loop]
    TestWord! $2f# 0#           {'/'}
    [if=0
       Factor!
       0% Divide! 0%=
       loop]
  ]
  0% Value= 2++                 {Make stack value the result}
  pop ret
] Term=

[def
  \serialRaw, $7f^              {Test for [Del] as break request}
  [if=0
    Prompt!                     {'Break'}
      $42# $72# $65# $61# $6b#
      0#]
  ret
] TestBreak=

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 10                                     |
+-----------------------------------------------------------------------}
$0aa0:

{ Process an expression factor, result in Value }
[def
  push

  Spaces!
  TestWord! $28# 0#             {'('}
  [if=0
    Expression!
    Spaces!
    TestWord! $29# 0#           {')'}
    [if<>0 SyntaxError!]
    pop ret]

  TestNumber!                   {Test for numeric constant}
  [if>=0 pop ret]               {Result already in Value}

  TestVar!                      {Otherwise it MUST be a variable}
  deek Value=                   {Fetch value}

  pop ret
] Factor=

{ List program }
[def
  $0ec0                         {Start of program memory}
  [do
    j=
    End^ if<>0                  {Repeat until the last line}
    TestBreak!                  {Test for [Del] as break request}
    j; Value= PrintValue!       {Print line number}
    j<++                        {Print line text}
    [do
      j<++ j,
      if<>0 PrintChar!
      loop]
    Newline!
    j NextBlock!                {Advance to next line in memory}
  loop]
  EndOfLine!
] List=

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 11                                     |
+-----------------------------------------------------------------------}
$0ba0:

{ Calculate vAC / Value, result in vAC, remainder in i }
[def
  j=                            {i:j is the Remainder:Quotient pair}
  Value^ k=                     {Park sign information}
  j     [if<0 0 j-     j=    ]  {Non-negative}
  Value [if<0 0 Value- Value=]  {Non-negative}
  [if=0 ValueError!]            {Avoid division by zero}

  0 i=
  [do
    tmp=                        {Loop counter}
    i i+ i=                     {Shift left}
    j [if<0 i<++]               {Carry bit over to i}
    j j+ j=                     {Shift left}
    i Value- [if>=0 i= j<++]    {Result bit}
    tmp 1+ 15&                  {Iterate 16 times}
    if<>0loop]

  k [if<0 0 j- ret]             {Return with corrected sign}
  j ret
] {Divide=}

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 12                                     |
+-----------------------------------------------------------------------}
$0ca0:
Divide=

{ Calculate vAC * Value, result in vAC }
[def
  tmp=
  [if<0                         {Make left-hand side positive}
    0 Value- Value=
    0 tmp- tmp=]

  0 j=                          {Result variable}
  1                             {First bit}
  [do                           {Loop over all bits}
    i= tmp&                     {Test next bit}
    [if<>0 j Value+ j=]         {Add partial term}
    Value Value+ Value=         {Double right-hand side}
    i i+ if>0loop]              {Shift left until all done}
  j
  ret
] Multiply=

[def
  Prompt! $53# $74# $61# $63#   {'Stack'}
    $6b# 0#
] StackError=

[def
  Prompt! $53# $79# $6e# $74#   {'Syntax'}
    $61# $78# 0#
] SyntaxError=

[def
  Prompt! $56# $61# $6c# $75#   {'Value'}
    $65# 0#
] {ValueError=}

{-----------------------------------------------------------------------+
|}\vLR>++ ret{          RAM page 13                                     |
+-----------------------------------------------------------------------}
$0da0:
ValueError=

{ Error reporting function and re-entry point for main loop }
{ Call with inline partial error message, or with 0# for silent re-entry }
[def
  \vLR; tmp=                    {vLR points to inline string argument}
  [Pos<, if<>0 Newline!]        {Conditional newline}
  tmp, [if=0                    {Test for error in first byte of message}
    PrintS! $4f# $6b# 0#        {'Ok'}
  else
    $3f                         {Begin error messages with '?'}
    [do                         {Print inline string as prelude}
      PrintChar!
      tmp, tmp<++
      if<>0loop]
    PrintS!                     {' error'}
      $20# $65# $72# $72# $6f#
      $72# 0#
    \vSP.                       {Reset stack}
    32-                         {$ffe0}
    Active&                     {Align to begin of block}
    {2+} deek                   {Fetch active line number}
    [if<>0                      {Input buffer has line number 0, don't print}
      Value=                    {Prepare line number for printing}
      PrintS!                   {' in '}
        $20# $69# $6e# $20# 0#
      PrintValue!]]             {Print line number}
  \LDWI#                        {1-byte hack to fall through and skip 'Error='}
] Prompt=

Newline!                        {Newline after prompt, error or welcome}

{ Main loop }
[do
  GetLine!                      {Get line from console}
  Active=                       {Parse from start of buffer}
  Spaces!
  Active, if=0loop              {Do nothing for empty lines}
  TryInsertLine!                {Test for line number to insert (or delete)}
  if>0loop]                     {If found, continue without prompt}
Statement!                      {Execute statement}

