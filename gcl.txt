-------------------------------
Gigatron Control Language (GCL)
-------------------------------
GCL is an interpreted low-level language for writing simple games for
the Gigatron TTL microcomputer, without bothering with the harsh timing
requirements of the hardware platform.

Technically, "GCL" is the source language or notation, while "vCPU" is the
virtual CPU, or interpreter, that is executing compiled GCL instructions.
The two are closely tied together.

---------------
Example program
---------------
{Draw the binary value of the largest 16-bit Fibonacci number on screen}

[do                                     {Approximate BASIC equivalent}
  0 a=                                  {10 A=0}
  1 b=                                  {20 B=1}
  [do
    a b+ c=                             {30 C=A+B}
    b a= c b=                           {40 A=B: B=C}
    if>0 loop]                          {50 IF B>0 THEN 30}
  $4448 d= {Middle of screen}           {60 D=$4448: REM MIDDLE OF SCREEN}
  [do
    c [if<0 15 d! else 5 d!]            {70 IF C<0 POKE D,15 ELSE POKE D,5}
    c c+ c=                             {80 C=C+C}
    d 1+ d=                             {90 D=D+1}
    -$4458 d+ if<0 loop]                {100 IF D<$4458 THEN 70}
  loop]                                 {110 GOTO 10}

-----------------
Programming model
-----------------
GCL draws most of its inspiration from SWEET16 (Apple II) and FALSE (Amiga),
two rather notable mini-languages.
The programming model is primarily "accumulator oriented".
To accommodate the lack of relative addressing and hardware stack on the host
CPU, expression and call stacks will be (mostly) static instead of dynamic.

The virtual regisers at all 16-bits and reside in the zero page.

vAC is the virtual accumulator, used by instructions as operand and/or result.
vPC is the virtual program counter. Programs run from RAM. When executing, vPC
    auto-increments just its low byte, so it wraps around on the same RAM page.
    (Code normally doesn't "use" this.) Function calls can go across pages.
vRT is the stored program counter pointing to the instruction after the most
    recent CALL instruction. This is used to return after making a subroutine
    call. When nesting subroutines, vRT should be pushed on the stack.
vSP is the stack pointer. The stack lives in the zero page top and grows down.
    Although vSP is 16-bits, only the low byte is in use and the high byte is 0.

Program variables are 16-bit words and typically hold a number or a pointer.
Named variables reside in the zero page. Arbitrary memory can be addressed
as bytes using 16-bit pointers.

-----------------
Notes on notation
-----------------
GCL programs are written as a long sequence of "words" without much structure
enforced by the compiler. Most words map directly to a single virtual
instruction and therefore also encode an embedded operand (e.g. 1+). Many words
operate on both vAC and some variable or constant. Sequences can be grouped
with () {} or [], each of which has its own meaning. Spaces and newlines simply separate words. Use indentation for clarity. There is no need for spaces around
the grouping characters []{}().
Constants are decimal, or hexadecimal when preceded with '$'.
Constants can be preceded by '-' or '+' (note: -$1000, not $-0000).
In "version 0" we can only use single upper case letters A-Z for variable names.
The overview below uses the following conventions:
'i' indicates an 8-bit integer constant.
'ii' indicates a 16-bit integer constant.
'X' indicates a named variable. Variables are global.

--------------------
Meaning of GCL words
--------------------

Basics
------
{...}                   Comments ignored by machine. Comments can be nested
i ii                    Load integer constant into vAC, e.g. 1, +1972, -$be05
X=                      Store vAC into variable X
X                       Load variable X into vAC
X+ X-                   Add/subtract variable X to/from vAC
i+ i-                   Add/subtract small constant to/from vAC
i& i| i^                Logical AND/OR/XOR vAC with small constant
X<! X>!                 Store vAC as byte into the low/high byte of variable X
X<? X>?                 Read low/high byte of variable X
X<++ X>++               Increment low/high byte of variable X

Memory
------
X?                      Read unsigned byte from memory pointed by X into vAC
X!                      Write vAC as byte to memory pointed by variable
i?                      Read zero page address i as unsigned byte into vAC
i!                      Store vAC as byte into zero page address i
i;                      ROM table lookup from address vAC + 256*i
lookup                  Alias for '0;'

Structured programming
----------------------
[...]                   Code block, used with "if", "else", "do", "loop"
if>0                    Continue executing code if vAC>0, otherwise jump to
                        end of the block (or past an optional matching "else")
                        Conditions are "=0" ">0" "<0" "<=0" ">=0" "<>0"
else                    When encountered, skip rest of code until end of block
do                      Mark the start of a loop
loop                    Jump back to matching "do"
if>0loop                Optimization for "if>0 loop" (works with all conditions)
def                     Load next vPC in vAC and jump to end of current block.

Subroutines
-----------
call                    Jump to vAC, store vPC in vRT
ret                     Jump to vRT, to return from a leaf subroutine
push                    Push vRT onto stack, for entering a non-leaf subroutine
pop                     Remove top of stack and put value in vAC
return                  Return from non-leaf subroutines (alias for "pull call")

Data
----
"Text"                  Text string (XXX zero termination?)
i.                      Raw byte-value i

----------------------
vCPU instruction table
----------------------
The vCPU implements 23 instructions. Each opcode is just a jump offset
into the interpreter code page to the code that implements it. Most
instructions take a single byte operand, but some have two and others none.

Opcode Operands Description
------ -------- -----------
LDWI   $DDDD    Load immediate constant (vAC=$DDDD)
LDI    $DD      Load immediate constant (vAC=$DD)
LD     $DD      Load byte from zero page (vAC=[D])
ST     $DD      Store byte in zero page ([D]=vAC)
LDW    $DD      Word load from zero page (vAC=[D]+256*[D+1])
STW    $DD      Word load from zero page ([D]=vAC&255,[D+1]=vAC/256)
ADDW   $DD      Word addition with zero page (vAC+=[D]+256*[D+1])
SUBW   $DD      Word subtraction with zero page (vAC-=[D]+256*[D+1])
ADDI   $DD      Add small positive constant (vAC+=D)
SUBI   $DD      Subtract small positive constant (vAC+=D)
INC    $DD      Increment zero page byte ([D]++)
ANDI   $DD      Logical-AND with constant (vAC&=D)
ORI    $DD      Logical-OR with constant (vAC|=D)
XORI   $DD      Logical-XOR with constant (vAC^=D)
PEEK   -        Read byte from memory (vAC=[vAC])
POKE   $DD      Write byte in memory ([[D+1],[D]]=vAC)
LOOKUP $DD      ROM lookup (vAC=ROM[AC+256*D])
COND   $CC $DD  Test vAC and branch conditionally. CC can be EQ,NE,LT,GT,LE,GE
BRA    $DD      Branch unconditionally (vPC=D+256*(vPC/256))
CALL   -        Goto address but remember vPC (vRT=vPC+1, vPC=vAC-2)
PUSH   -        Push value on stack ([--vSP]=vRT&255,[--vSP]/256)
PULL   -        Pop value from stack(vAC=[vSP]+256*[vSP+1], vSP+=2)
SYS    $DD      Native function call for at most $DD ticks ($DD*2 cycles)
TBD1   $DD      To be defined (placeholder)
TBD2   $DD      To be defined (placeholder) Decrement and loop?

-- End of document --
