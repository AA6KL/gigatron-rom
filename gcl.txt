-------------------------------
Gigatron Control Language (GCL)
-------------------------------
GCL is an interpreted low-level language for writing simple games for
the Gigatron TTL microcomputer, without bothering with the harsh timing
requirements of the hardware platform.

Technically, "GCL" is the source language or notation, while "vCPU" is the
virtual CPU, or interpreter, that is executing compiled GCL instructions.
The two are closely tied together.

---------------
Example program
---------------

gcl1 {GCL version}

{Draw the binary value of the largest 16-bit Fibonacci number on screen}

[do                                     {Approximate BASIC equivalent}
  0 a=                                  {10 A=0}
  1 b=                                  {20 B=1}
  [do
    a b+ c=                             {30 C=A+B}
    b a= c b=                           {40 A=B: B=C}
    if>0 loop]                          {50 IF B>0 THEN 30}
  $4448 d= {Middle of screen}           {60 D=$4448: REM MIDDLE OF SCREEN}
  [do
    c [if<0 15 d. else 5 d.]            {70 IF C<0 POKE D,15 ELSE POKE D,5}
    c c+ c=                             {80 C=C+C}
    d 1+ d=                             {90 D=D+1}
    -$4458 d+ if<0 loop]                {100 IF D<$4458 THEN 70}
  loop]                                 {110 GOTO 10}


-----------------
Programming model
-----------------
GCL draws most of its inspiration from two notable mini-languages: SWEET16
(Apple II) and FALSE (Amiga). There is also a little bit of FORTH influence.
The GCL programming model is primarily "accumulator oriented".
To accommodate the lack of relative addressing and hardware stack on the host
CPU, expression and call stacks will be (mostly) static instead of dynamic.

The virtual regisers are 16-bits (except vSP) and reside in the zero page.

vAC  is the virtual accumulator, used by instructions as operand and/or result
vPC  is the virtual program counter. Programs run from RAM. When executing, vPC
     auto-increments just its low byte, so it wraps around on the same RAM page.
     (Code normally doesn't "use" this.) Function calls can go across pages.
vLR  is the link register. It points to the instruction following the most recent
     CALL instruction. This is used to return after making a subroutine
     call. When nesting subroutines, vLR should be pushed on the stack.
vSP  is the stack pointer. The stack lives in the zero page top and grows down.

Program variables are 16-bit words and typically hold a number or a pointer.
Named variables reside in the zero page. Arbitrary memory can be addressed
as bytes using 16-bit pointers.

-----------------
Notes on notation
-----------------
GCL programs are written as a long sequence of "words" without much structure
enforced by the compiler. Most words map directly to a single virtual
instruction and therefore also encode an embedded operand (e.g. 1+). Many words
operate on both vAC and some variable or constant. Sequences can be grouped
with () {} or [], each of which has its own meaning. Spaces and newlines simply
separate words. Use indentation for clarity. There is no need for spaces around
the grouping characters []{}().
Constants are decimal, or hexadecimal when preceded with '$'.
Constants can be preceded by '-' or '+' (note: -$1000, not $-0000).
For convenience, symbols defined by the host system can be referenced by
prefixing a backslash, e.g. '\fontData'. This can be used anywhere where an
integer is expected.
Variable names start with an alphanumeric character and are case sensitive.
The overview below uses the following conventions:
'i' indicates an 8-bit integer constant.
'ii' indicates a 16-bit integer constant.
'X' indicates a named variable. Variables are allocated globally on the zero page.

--------------------
Meaning of GCL words
--------------------

Basics
------
{...}                   Comments ignored by machine. Comments can be nested
i ii                    Load integer constant into vAC, e.g. 1, +1972, -$be05
X=                      Store vAC into variable X
X                       Load variable X into vAC
X+ X-                   Add/subtract variable X to/from vAC
i+ i-                   Add/subtract small constant to/from vAC
i& i| i^                Logical AND/OR/XOR vAC with small constant
X<. X>.                 Store vAC as byte into the low/high byte of variable X
X<, X>,                 Read low/high byte of variable X
X<++ X>++               Increment low/high byte of variable X

Memory
------
X,                      Read unsigned byte from memory pointed by X into vAC
peek                    Read byte from memory pointed by vAC
X.                      Write vAC as byte to memory pointed by variable
i,                      Read zero page address i as unsigned byte into vAC
i;                      Read variable at zero page address into vAC
i.                      Store vAC as byte into zero page address i
i?                      ROM table lookup from address vAC+i

Structured programming
----------------------
[...]                   Code block, used with "if", "else", "do", "loop"
if>0                    Continue executing code if vAC>0, otherwise jump to
                        end of the block (or past an optional matching "else")
                        Conditions are "=0" ">0" "<0" "<=0" ">=0" "<>0"
else                    When encountered, skip rest of code until end of block
do                      Mark the start of a loop
loop                    Jump back to matching "do"
if>0loop                Optimization for "if>0 loop" (works with all conditions)
def                     Load next vPC in vAC and jump to end of current block.

Subroutines
-----------
X!                      Jump to function pointed by X, store old vPC in vLR
call                    Jump to function pointed by vAC, store old vPC in vLR
ret                     Jump to vLR, to return from a leaf subroutine. Non-leaf
                        subroutines should use "pop ret" as return sequence
push                    Push vLR onto stack, for entering a non-leaf subroutine
pop                     Remove top of stack and put value in vLR
i!                      Call native code pointed by vAC, needing at most i cycles

Data
----
i#                      Raw byte-value i
"Text"                  Text string XXX Not implementd

Versioning
----------
gcl0x gcl1              GCL version. Suffix 'x' denotes experimental/extended versions

----------------------
vCPU instruction table
----------------------
The vCPU interpreter has 25 core instructions. Each opcode is just a jump offset
into the interpreter code page to the code that implements its behavior. Most
instructions take a single byte operand, but some have two and others none.

Opcode Operands Description
------ -------- -----------
LDWI   $DDDD    Load immediate constant (vAC=$DDDD)
LDI    $DD      Load immediate constant (vAC=$DD)
LD     $DD      Load byte from zero page (vAC=[D])
ST     $DD      Store byte in zero page ([D]=vAC)
LDW    $DD      Word load from zero page (vAC=[D]+256*[D+1])
STW    $DD      Store word into zero page ([D]=vAC&255,[D+1]=vAC>>8)
ADDW   $DD      Word addition with zero page (vAC+=[D]+256*[D+1])
SUBW   $DD      Word subtraction with zero page (vAC-=[D]+256*[D+1])
ADDI   $DD      Add small positive constant (vAC+=D)
SUBI   $DD      Subtract small positive constant (vAC+=D)
INC    $DD      Increment zero page byte ([D]++)
ANDI   $DD      Logical-AND with constant (vAC&=D)
ORI    $DD      Logical-OR with constant (vAC|=D)
XORI   $DD      Logical-XOR with constant (vAC^=D)
PEEK   -        Read byte from memory (vAC=[vAC])
POKE   $DD      Write byte in memory ([[D+1],[D]]=vAC&255)
LOOKUP $DD      ROM lookup (vAC=ROM[AC+256*D])
BRA    $DD      Branch unconditionally (vPC=(vPC&0xff00)+D)
BCC    $CC $DD  Test vAC and branch conditionally. CC can be EQ,NE,LT,GT,LE,GE
CALL   $DD      Goto address but remember vPC (vLR,vPC=vPC+2,[D]+256*[D+1]-2)
RET    -        Leaf return (vPC=vLR-2)
PUSH   -        Push vLR on stack ([--vSP]=vLR&255,[--vSP]=vLR>>8)
POP    -        Pop value from stack (vAC=[vSP]+256*[vSP+1],vSP+=2) XXX should restore to vLR
SYS    $DD      Native function call for at most $DD ticks ($DD*2 cycles)
DEF    $DD      Define data or code (vAC,vPC=vPC+2,D+256*(vPC>>8))

-- End of document --
