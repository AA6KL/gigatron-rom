gcl0x
{-----------------------------------------------------------------------+
|                                                                       |
|       Apple-1 mockup                                                  |
|       For testing original WozMon code on v6502                       |
|                                                                       |
+-----------------------------------------------------------------------}

{
 Issues:
  XXX Pack variables Pos,PrintChar,WozMon variables,i,j,k
  XXX Smaller screen so there's more space for real programs (top 16 lines = 4K)
  XXX BRK as a way to return to monitor ($FFFE/$FFFF) after R, can it be done?
      (Proper way to return is by JMP $FF1F)
  XXX Shift screen memory 96 pixels right
  XXX Disable sound channels
}

{-----------------------------------------------------------------------+
|       ROM type check                                                  |
+-----------------------------------------------------------------------}

\romType, \romTypeValue_DEVROM- {Need version >= DEVROM, see Docs/GT1-files.txt}
[if<0 do \frameCount;           {https://forum.gigatron.io/viewtopic.php?f=4&t=130}
  #\DOKE #\vPCH loop]

{-----------------------------------------------------------------------+
|       Initialize                                                      |
+-----------------------------------------------------------------------}

{ This code runs once and is then reused as the input buffer }

{ Setup video indirection table such that WozMon can be at $7F00/$FF00 }
\videoTable Pos=                {First variable $30, later becomes Pos}
120                             {7^127}
[do 127^                        {Loop over 7..126 range}
  Pos: <Pos++ <Pos++            {Y[y]=7+j and dX[y]=0}
  1+ 127^ if<>0loop]            {Next in range}

\_PrintChar PrintChar=          {Forward reference}
\Apple1 \vLR:                   {Prepare transfer to main loop}
\Munch                          {Start address for Munching6502}
[ret]                           {Jump to Main (the brackets avoid the automatic vLR patch)}

{-----------------------------------------------------------------------+
|       Preloaded demo program                                          |
+-----------------------------------------------------------------------}

*=$280

Munch=* #$18                    { Munch clc             }
        #$69 #$17               {       adc #23         XXX idea: #\ADCzp  #23}
        #$85 #$40               {       sta $40         }
        #$a9 #$00               {       lda #0          }
        #$85 #$41               {       sta $41         }
        #$a9 #$10               {       lda #16         }
        #$85 #$42               {       sta $42         }
        #$a9 #$07               { nextT lda #$07        }
        #$85 #$43               {       sta $43         }
        #$45 #$41               { nextY eor $41         }
        #$a8                    {       tay             }
        #$a5 #$40               {       lda $40         }
        #$91 #$42               {       sta ($42),y     }
        #$e6 #$43               {       inc $43         }
        #$a5 #$43               {       lda $43         }
        #$c9 #$7f               {       cmp #$7f        }
        #$d0 #$f1               {       bne *-15        nextY}
        #$a5 #\serialRaw        {       lda serialRaw   }
        #$c9 #$03               {       cmp #3          Ctrl-C}
        #$f0 #$09               {       beq out         }
        #$e6 #$41               {       inc $41         }
        #$10 #$e3               {       bpl *-29        nextT}
        #$a5 #$40               {       lda $40         }
        #$4c #$80 #$02          {       jmp Munch       }
        #$a9 #$8d               {       lda #$8d        Force initial LF and reset of Pos}
        #$00                    {       brk             }
        #$4c #$00 #$ff          {       jmp WozMon      }

{-----------------------------------------------------------------------+
|       Main loop                                                       |
+-----------------------------------------------------------------------}

*=$300

Apple1=*

\vLR:                           {Reset v6502 PC}
[do
  $0b0c \sysFn:                 {Set SYS call to SYS_v6502_Run_vX_80}
  k                             {ASCII code in A}
  80!                           {Run 6502 code until BRK}
  push                          {Save v6502 PC}
  [if=0                         {A=0 reads from keyboard}
    [do
      \serialRaw, 255^          {Wait for idle keyboard}
      if<>0loop]
    [do
      \frameCount, 48&          {Roughly 1 Hz and 75% duty cycle}
      [if=0 $a0 else $c0]       {Select space or '@'}
      PrintChar! Pos=           {Display cursor and go back}
      \serialRaw, k= 128&       {Key ready?}
      if<>0loop]                {Loop until ready}
    $a0 PrintChar! Pos=         {Overwrite '@' with a space}
    k $60- [if>=0 $40+ k=]      {Map to upper case, and DEL to rubout}
    k  10^ [if=0  13 k=]        {Map LF to CR}
  else                          {A<>0 for echo}
    k=
    PrintChar!
  ]
  pop                           {Restore v6502 PC}
  loop]                         {Back to wozmon}

{-----------------------------------------------------------------------+
|       Character output with automatic scrolling                       |
+-----------------------------------------------------------------------}

_PrintChar=*
[
  {Minimalistic terminal output, with bit 7 set by WozMon}

  %$fe=                         {Park character in stack area}
  \SYS_VDrawBits_134 \sysFn:    {Prepare SYS calls}
  $800 \sysArgs0:               {Green on black}

  %$fe                          {Get character back}
  $8d^ [if<>0                   {Test for CR...}
    <Pos, 155- if>0 0]          {...or line wrap}

  [if=0

    {-------------------------------------------------------------------+
    |       Newline                                                     |
    +-------------------------------------------------------------------}

    {Clear new line first}

    $100 <Pos. peek >Pos. Pos   {Go to start of next line}
    \sysArgs4:                  {Set screen position}
    \sysArgs2.                  {Set all-zero output pattern}
    [do
      134!                      {SYS call to draw 8 pixels vertically}
      <\sysArgs4++              {Step 1 pixel right}
      \sysArgs4, 160^           {Test for end of line}
      if<>0loop]

    {Then scroll up by modifying videoTable}

    $01ee i=                    {Last entry in video table}
    [do
      i, 119- [if<0 127+
               else 7+] i.      {Rotate by 8 in 7..126 range}
      i 2- i=                   {Move to previous entry in video table}
      $fe^ if<>0loop]           {Until all done}
  ]

  %$fe $a0-                     {WozMon sends ASCII with bit 7 set}
  [if>=0                        {If printable}

    {-------------------------------------------------------------------+
    |       PrintChar                                                   |
    +-------------------------------------------------------------------}

    { Draw ASCII character (32..127) on screen in 5x8 pixels }
    { and advance cursor position }

    50-                         {Map ASCII code to offset in font table}
    [if<0 50+ i= \font32up      {ASCII 32..81}
     else     i= \font82up] j=  {ASCII 82..127}
    i 2<< i+                    {Multiply char code by 5}
    j+ j=                       {Add to page address to reach bitmap data}

    Pos \sysArgs4:              {Screen position for character}
    %$fe=                       {Remember this position}
    6+ Pos=                     {Advance by 6 pixels}

    5 [do i=                    {Draw character as 5 vertical bit slices}
      j 0? \sysArgs2.           {Get bit slice as byte from ROM table}
      134!                      {SYS call to draw 8 pixels vertically}
      <j++ <\sysArgs4++         {Advance to next byte}
      i 1- if>0loop]            {Looping}

    %$fe                        {Return position for backspace}
  ]

  ret
]

{-----------------------------------------------------------------------+
|       WozMon                                                          |
+-----------------------------------------------------------------------}

*=$ff00

WozMon=*

{FF00} #$D8           { RESET:          CLD             Clear decimal arithmetic mode.          }
{FF01} #$58           {                 CLI                                                     }
{FF02} #$A0 #$7F      {                 LDY #$7F        Mask for DSP data direction register.   }
{FF04} #$2C #$12 #$D0 {         .BYTE   $2C,$12,$D0     [Gigatron] BIT DSP (was: STY DSP)       }
{FF07} #$A9 #$A7      {                 LDA #$A7        KBD and DSP control register mask.      }
{FF09} #$2C #$11 #$D0 {         .BYTE   $2C,$11,$D0     [Gigatron] BIT KBDCR (was: STA KBDCR)   }
{FF0C} #$2C #$13 #$D0 {         .BYTE   $2C,$13,$D0     [Gigatron] BIT DSPCR (was: STY DSPCR)   }
{FF0F} #$C9 #$DF      { NOTCR:          CMP #$DF        "<-"?                                   }
{FF11} #$F0 #$13      {                 BEQ BACKSPACE   Yes.                                    }
{FF13} #$C9 #$9B      {                 CMP #$9B        ESC?                                    }
{FF15} #$F0 #$03      {                 BEQ ESCAPE      Yes.                                    }
{FF17} #$C8           {                 INY             Advance text index.                     }
{FF18} #$10 #$0F      {                 BPL NEXTCHAR    Auto ESC if > 127.                      }
{FF1A} #$A9 #$DC      { ESCAPE:         LDA #$DC        "\".                                    }
{FF1C} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FF1F} #$A9 #$8D      { GETLINE:        LDA #$8D        CR.                                     }
{FF21} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FF24} #$A0 #$01      {                 LDY #$01        Initiallize text index.                 }
{FF26} #$88           { BACKSPACE:      DEY             Back up text index.                     }
{FF27} #$30 #$F6      {                 BMI GETLINE     Beyond start of line, reinitialize.     }
{FF29} #$A9 #$00      { NEXTCHAR:       LDA #$00        [Gigatron] A=0 to read keyboard.        }
{FF2B} #$00           {                 BRK             [Gigatron] Transfer to vCPU for input.  }
{FF2C} #$09 #$80      {                 ORA #$80        [Gigatron] B7 should be '1'.            }
{FF2E} #$2C #$10 #$D0 {         .BYTE   $2C,$10,$D0     [Gigatron] BIT KBD (was: LDA KBD)       }
{FF31} #$99 #$00 #$02 {                 STA IN,Y        Add to text buffer.                     }
{FF34} #$20 #$EF #$FF {                 JSR ECHO        Display character.                      }
{FF37} #$C9 #$8D      {                 CMP #$8D        CR?                                     }
{FF39} #$D0 #$D4      {                 BNE NOTCR       No.                                     }
{FF3B} #$A0 #$FF      {                 LDY #$FF        Reset text index.                       }
{FF3D} #$A9 #$00      {                 LDA #$00        For XAM mode.                           }
{FF3F} #$AA           {                 TAX             0->X.                                   }
{FF40} #$0A           { SETSTOR:        ASL             Leaves $7B if setting STOR mode.        }
{FF41} #$85 #$4B      { SETMODE:        STA MODE        $00 = XAM, $7B= STOR,$AE= BLOK XAM      }
{FF43} #$C8           { BLSKIP:         INY             Advance text index.                     }
{FF44} #$B9 #$00 #$02 { NEXTITEM:       LDA IN,Y        Get character.                          }
{FF47} #$C9 #$8D      {                 CMP #$8D        CR?                                     }
{FF49} #$F0 #$D4      {                 BEQ GETLINE     Yes, done this line.                    }
{FF4B} #$C9 #$AE      {                 CMP #$AE        "."?                                    }
{FF4D} #$90 #$F4      {                 BCC BLSKIP      Skip delimiter.                         }
{FF4F} #$F0 #$F0      {                 BEQ SETMODE     Yes, BLOCK XAM mode.                    }
{FF51} #$C9 #$BA      {                 CMP #$BA        ":"?                                    }
{FF53} #$F0 #$EB      {                 BEQ SETSTOR     Yes, set STOR mode.                     }
{FF55} #$C9 #$D2      {                 CMP #$D2        "R"?                                    }
{FF57} #$F0 #$3B      {                 BEQ RUN         Yes, run user program.                  }
{FF59} #$86 #$48      {                 STX L           $00->L.                                 }
{FF5B} #$86 #$49      {                 STX H            and H.                                 }
{FF5D} #$84 #$4A      {                 STY YSAV        Save Y for comparison.                  }
{FF5F} #$B9 #$00 #$02 { NEXTHEX:        LDA IN,Y        Get character for hex test.             }
{FF62} #$49 #$B0      {                 EOR #$B0        Map digits to $0-9.                     }
{FF64} #$C9 #$0A      {                 CMP #$0A        Digit?                                  }
{FF66} #$90 #$06      {                 BCC DIG         Yes.                                    }
{FF68} #$69 #$88      {                 ADC #$88        Map letter "A"-"F" to $FA-FF.           }
{FF6A} #$C9 #$FA      {                 CMP #$FA        Hex letter?                             }
{FF6C} #$90 #$11      {                 BCC NOTHEX      No, character not hex.                  }
{FF6E} #$0A           { DIG:            ASL                                                     }
{FF6F} #$0A           {                 ASL             Hex digit to MSD of A.                  }
{FF70} #$0A           {                 ASL                                                     }
{FF71} #$0A           {                 ASL                                                     }
{FF72} #$A2 #$04      {                 LDX #$04        Shift count.                            }
{FF74} #$0A           { HEXSHIFT:       ASL             Hex digit left, MSB to carry.           }
{FF75} #$26 #$48      {                 ROL L           Rotate into LSD.                        }
{FF77} #$26 #$49      {                 ROL H           Rotate into MSD's.                      }
{FF79} #$CA           {                 DEX             Done 4 shifts?                          }
{FF7A} #$D0 #$F8      {                 BNE HEXSHIFT    No, loop.                               }
{FF7C} #$C8           {                 INY             Advance text index.                     }
{FF7D} #$D0 #$E0      {                 BNE NEXTHEX     Always taken. Check next character for hex.}
{FF7F} #$C4 #$4A      { NOTHEX:         CPY YSAV        Check if L, H empty (no hex digits).    }
{FF81} #$F0 #$97      {                 BEQ ESCAPE      Yes, generate  ESC sequence.            }
{FF83} #$24 #$4B      {                 BIT MODE        Test MODE byte.                         }
{FF85} #$50 #$10      {                 BVC NOTSTOR     B6 = 0 for STOR, 1 for XAM and BLOCK XAM}
{FF87} #$A5 #$48      {                 LDA L           LSD's of hex data.                      }
{FF89} #$81 #$46      {                 STA (STL,X)     Store at current 'store index'.         }
{FF8B} #$E6 #$46      {                 INC STL         Increment store index.                  }
{FF8D} #$D0 #$B5      {                 BNE NEXTITEM    Get next item. (no carry).              }
{FF8F} #$E6 #$47      {                 INC STH         Add carry to 'store index' high order.  }
{FF91} #$4C #$44 #$FF { TONEXTITEM:     JMP NEXTITEM    Get next command item.                  }
{FF94} #$6C #$44 #$00 { RUN:            JMP (XAML)      Run at current XAM index.               }
{FF97} #$30 #$2B      { NOTSTOR:        BMI XAMNEXT     B7 = 0 for XAM, 1 for BLOCK XAM.        }
{FF99} #$A2 #$02      {                 LDX #$02        Byte count.                             }
{FF9B} #$B5 #$47      { SETADR:         LDA L-1,X       Copy hex data to                        }
{FF9D} #$95 #$45      {                 STA STL-1,X       'store index'.                        }
{FF9F} #$95 #$43      {                 STA XAML-1,X    And to 'XAM index'.                     }
{FFA1} #$CA           {                 DEX             Next of 2 bytes.                        }
{FFA2} #$D0 #$F7      {                 BNE SETADR      Loop unless X = 0.                      }
{FFA4} #$D0 #$14      { NXTPRNT:        BNE PRDATA      NE means no address to print.           }
{FFA6} #$A9 #$8D      {                 LDA #$8D        CR.                                     }
{FFA8} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FFAB} #$A5 #$45      {                 LDA XAMH        'Examine index' high-order byte.        }
{FFAD} #$20 #$DC #$FF {                 JSR PRBYTE      Output it in hex format.                }
{FFB0} #$A5 #$44      {                 LDA XAML        Low-order 'examine index' byte.         }
{FFB2} #$20 #$DC #$FF {                 JSR PRBYTE      Output it in hex format.                }
{FFB5} #$A9 #$BA      {                 LDA #$BA        ":".                                    }
{FFB7} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FFBA} #$A9 #$04      { PRDATA:         LDA #$04        [Gigatron] 4 pixels wide blank.         }
{FFBC} #$20 #$F3 #$FF {                 JSR BLANK       [Gigatron] Output it.                   }
{FFBF} #$A1 #$44      {                 LDA (XAML,X)    Get data byte at 'examine index'.       }
{FFC1} #$20 #$DC #$FF {                 JSR PRBYTE      Output it in hex format.                }
{FFC4} #$86 #$4B      { XAMNEXT:        STX MODE        0->MODE (XAM mode).                     }
{FFC6} #$A5 #$44      {                 LDA XAML                                                }
{FFC8} #$C5 #$48      {                 CMP L           Compare 'examine index' to hex data.    }
{FFCA} #$A5 #$45      {                 LDA XAMH                                                }
{FFCC} #$E5 #$49      {                 SBC H                                                   }
{FFCE} #$B0 #$C1      {                 BCS TONEXTITEM  Not less, so no more data to output.    }
{FFD0} #$E6 #$44      {                 INC XAML                                                }
{FFD2} #$D0 #$02      {                 BNE MOD8CHK     Increment 'examine index'.              }
{FFD4} #$E6 #$45      {                 INC XAMH                                                }
{FFD6} #$A5 #$44      { MOD8CHK:        LDA XAML        Check low-order 'examine index' byte    }
{FFD8} #$29 #$07      {                 AND #$07          For MOD 8= 0                          }
{FFDA} #$10 #$C8      {                 BPL NXTPRNT     Always taken.                           }
{FFDC} #$48           { PRBYTE:         PHA             Save A for LSD.                         }
{FFDD} #$4A           {                 LSR                                                     }
{FFDE} #$4A           {                 LSR                                                     }
{FFDF} #$4A           {                 LSR             MSD to LSD position.                    }
{FFE0} #$4A           {                 LSR                                                     }
{FFE1} #$20 #$E5 #$FF {                 JSR PRHEX       Output hex digit.                       }
{FFE4} #$68           {                 PLA             Restore A.                              }
{FFE5} #$29 #$0F      { PRHEX:          AND #$0F        Mask LSD for hex print.                 }
{FFE7} #$09 #$B0      {                 ORA #$B0        Add "0".                                }
{FFE9} #$C9 #$BA      {                 CMP #$BA        Digit?                                  }
{FFEB} #$90 #$02      {                 BCC ECHO        Yes, output it.                         }
{FFED} #$69 #$06      {                 ADC #$06        Add offset for letter.                  }
{FFEF} #$48           { ECHO:           PHA             [Gigatron]                              }
{FFF0} #$00           {                 BRK             [Gigatron] Transfer to vCPU for display.}
{FFF1} #$68           {                 PLA             [Gigatron]                              }
{FFF2} #$60           {                 RTS             [Gigatron] Return.                      }
{FFF3} #$18           { BLANK:          CLC             [Gigatron] Advance few pixels so BLOCK  }
{FFF4} #$65 #$30      {                 ADC $30         [Gigatron]   XAM doesn't wrap around    }
{FFF6} #$85 #$30      {                 STA $30         [Gigatron]   the 160 pixel wide screen. }
{FFF8} #$60           {                 RTS             [Gigatron]                              }
{FFF9} #$00           { (unused)                                                                }
{FFFA} #$00 #$00      { (NMI)                                                                   }
{FFFC} #$00 #$FF      { (RESET)                                                                 }
{FFFE} #$00 #$00      { (IRQ)                                                                   }

{-----------------------------------------------------------------------+
|                                                                       |
+-----------------------------------------------------------------------}

