gcl0x
{-----------------------------------------------------------------------+
|                                                                       |
|       Apple-1 mockup                                                  |
|       For testing original WozMon code on v6502                       |
|                                                                       |
+-----------------------------------------------------------------------}

{
 Issues:
  XXX Shift screen memory 96 pixels right
  XXX NMI/IRQ/RESET to wozmon (through vector) without going through main menu
  XXX Smaller screen so there's more space for real programs (top 16 lines = 4K)
  XXX We can win memory by sharing all black pixel lines in one page
      But drawing characters then touches the top line
      - Option 1: VDRawBits7
      - Option 2: Always hide top line
      - Option 3: New draw transparent plot function, clear with SetBytes
      - Option 4: Vary which page is the black line, will be the bottom line
                  -> doesn't work at memory wrap-around
      - Option 5: New videoTable-aware (character) plot function
      - Option 6: use Sprite functions for plotting chars
  XXX Print a welcome message (only on first boot)
  XXX Possible memory map with compressed video memory
        +--------------------------+
        |30-7F,81-FF FREE ZP+STACK!|
        |0100-01F9   VIDEO+SYSTEM  |
        |0200-0FFF   FREE RAM      | 1000-5FFF -> 80 scanlines
        |E000-EFFF   FREE RAM      | F000-FBFF -> 12 scanlines --> total 13*7+1
        |FC00-FD00   FREE RAM      |
        |FE00        KBD/DSP MOCKUP| Add entry points at D010-D013 = 5010-5013
        |FF00        WOZMON        |
        |                          |
        |C100R     LOADER MENU     |
        |E000R     BASIC COLD START|
        |E2B3R     BASIC WARM START|
        +--------------------------+
  XXX Emulate ACI Apple Cassete Interface? C100R --> 4100 = RAM (still ok)
  XXX       D010 60 KBD     RTS            <-- Or store keyboard value here
            D011 80 KBDCR   BRA $D037      NOK: (JMP $6024 = $E024)
            D012 24 DSP     BIT $60
            D013 60 DSPCR   RTS
            D014    _DSP:
            D037    _KBDCR:

        https://www.sbprojects.net/projects/apple1/a1basic.php

Zero page usage:
$30-$31         Pos
$32-$33         PrintChar
$34-$3b         WozMon variables
}
_i=$3c
_j=$3e
_k=$3a          {Share with wozmon YSAV}

{-----------------------------------------------------------------------+
|       ROM type check                                                  |
+-----------------------------------------------------------------------}

*=\userCode

\romType, \romTypeValue_ROMv4-  {Version check >= ROMv4, see Docs/GT1-files.txt}
[if<0 do _frameCount _vPCH:     {https://forum.gigatron.io/viewtopic.php?f=4&t=130}
      loop]

{-----------------------------------------------------------------------+
|       Initialize                                                      |
+-----------------------------------------------------------------------}

{ This code runs once and is then reused as the input buffer for wozmon }

{ Sacrifice sound channels 2,3,4 for a less fragmented memory map }
\channelMask_DEVROM, $f8& \channelMask_DEVROM.

{ Setup video indirection table such that WozMon can be at $7F00/$FF00 }
\videoTable Pos=                {First GCL variable at $30, later becomes Pos}
120                             {7^127}
[do 127^                        {Loop over 7..126 range}
  Pos: <Pos++ <Pos++            {Y[y]=7+j and dX[y]=0}
  1+ 127^ if<>0loop]            {Next in range}

&_PrintChar PrintChar=          {Forward reference}

&_Apple1 _vLR=                  {Prepare transfer to main loop}
&_Start                         {Start address for 6502 program}
[ret]                           {Jump to Main (the brackets avoid the automatic vLR patch)}

_Start=*
        #$a2 #15                {       ldx #15         Clear screen}
_L0=*   #$a9 #$8d               {       lda #$8d        }
        #$00                    {       brk             }
        #$ca                    {       dex             }
        #$d0 #@_L0              {       bne _L0         }
        #$f0 #@_Munch           {       beq _Munch      Always taken}

{-----------------------------------------------------------------------+
|       Preloaded demo program                                          |
+-----------------------------------------------------------------------}

*=$280

_Munch=* #$18                   { Munch clc             }
        #$69 #23                {       adc #23         }
        #$85 #$40               {       sta $40         }
        #$a9 #$00               {       lda #0          }
        #$85 #$41               {       sta $41         }
        #$a9 #$10               {       lda #16         }
        #$85 #$42               {       sta $42         }
_L1=*   #$a9 #$07               { nextT lda #$07        }
        #$85 #$43               {       sta $43         }
_L2=*   #$45 #$41               { nextY eor $41         }
        #$a8                    {       tay             }
        #$a5 #$40               {       lda $40         }
        #$91 #$42               {       sta ($42),y     }
        #$e6 #$43               {       inc $43         }
        #$a5 #$43               {       lda $43         }
        #$c9 #$7f               {       cmp #$7f        }
        #$d0 #@_L2              {       bne _L2         }
        #$a5 #_serialRaw        {       lda serialRaw   }
        #$c9 #$03               {       cmp #3          Ctrl-C}
        #$f0 #@_L3              {       beq _L3         }
        #$e6 #$41               {       inc $41         }
        #$10 #@_L1              {       bpl _L1         }
        #$a5 #$40               {       lda $40         }
        #$4c ##_Munch           {       jmp _Munch      }
_L3=*   #$a2 #54                {       ldx #54         }
_L4=*   #$bd ##_MSG             {       lda _MSG,x      }
        #$00                    {       brk             }
        #$ca                    {       dex             }
        #$10 #@_L4              {       bpl _L4         }
        #$4c ##_WozMon          {       jmp _WozMon     }

_MSG=*  { '\r\r'
          'TTL Apple 1\r'
          'FF00.FFFF Monitor\r'
          '280R      Munching6502\r' (reversed and +128) }
	#$8d #$b2 #$b0 #$b5 #$b6 #$e7 #$ee #$e9 #$e8 #$e3 #$ee #$f5
	#$cd #$a0 #$a0 #$a0 #$a0 #$a0 #$a0 #$d2 #$b0 #$b8 #$b2 #$8d
	#$f2 #$ef #$f4 #$e9 #$ee #$ef #$cd #$a0 #$c6 #$c6 #$c6 #$c6
	#$ae #$b0 #$b0 #$c6 #$c6 #$8d #$b1 #$a0 #$e5 #$ec #$f0 #$f0
	#$c1 #$a0 #$cc #$d4 #$d4 #$8d #$8d

{-----------------------------------------------------------------------+
|       Main loop                                                       |
+-----------------------------------------------------------------------}

*=$300

_Apple1=*

_vLR=                           {Reset v6502 PC}
[do
  \SYS_Run6502_DEVROM_80 _sysFn=
  \k,                           {ASCII code in A}
  80!                           {Run 6502 code until BRK}
  push                          {Save v6502 PC}
  [if=0                         {A=0 reads from keyboard}
    [do
      \serialRaw, 255^          {Wait for idle keyboard}
      if<>0loop]
    [do
      \frameCount, 15& [if=0    {4 Hz cursor redraw rate}
        \frameCount, 48&        {Flash at 1 Hz with 75% duty cycle}
        [if=0 $a0 else $c0]     {Select space or '@'}
        PrintChar! Pos=]        {Display cursor and move back}
      \serialRaw, \k. 128&      {Key ready?}
      if<>0loop]                {Loop until ready}
    $a0 PrintChar! Pos=         {Overwrite '@' with a space}
    \k, $60- [if>=0 $40+ \k.]   {Map to upper case, and DEL to rubout}
    \k, 10^  [if=0  13   \k.]   {Map LF to CR}
  else                          {A<>0 for echo}
    \k.
    PrintChar!
  ]
  pop                           {Restore v6502 PC}
  loop]                         {Back to wozmon}

{-----------------------------------------------------------------------+
|       Character output with automatic scrolling                       |
+-----------------------------------------------------------------------}

_PrintChar=*
[
  {Minimalistic terminal output, with bit 7 set by WozMon}

  %-2=                          {Park character in stack area}
  \SYS_VDrawBits_134 _sysFn=    {Prepare SYS calls}
  $800 \sysArgs0:               {Green on black}

  %-2                           {Get character back}
  $8d^ [if<>0                   {Test for CR...}
    <Pos, 155- if>0 0]          {...or line wrap}

  [if=0

    {-------------------------------------------------------------------+
    |       Newline                                                     |
    +-------------------------------------------------------------------}

    {Clear new line first}

    $100 <Pos. peek >Pos. Pos   {Go to start of next line}
    \sysArgs4:                  {Set screen position}
    \sysArgs2.                  {Set all-zero output pattern}
    [do
      134!                      {SYS call to draw 8 pixels vertically}
      <\sysArgs4++              {Step 1 pixel right}
      \sysArgs4, 160^           {Test for end of line}
      if<>0loop]

    {Then scroll up by modifying videoTable}

    $01ee _i=                   {Last entry in video table}
    [do
      _i, 119- [if<0 127+
                else 7+] _i.    {Rotate by 8 in 7..126 range}
      _i 2- _i=                 {Move to previous entry in video table}
      $fe^ if<>0loop]           {Until all done}
  ]

  %-2 $a0-                      {WozMon sends ASCII with bit 7 set}
  [if>=0                        {If printable}

    {-------------------------------------------------------------------+
    |       PrintChar                                                   |
    +-------------------------------------------------------------------}

    { Draw ASCII character (32..127) on screen in 5x8 pixels }
    { and advance cursor position }

    50-                         {Map ASCII code to offset in font table}
    [if<0 50+ _i= \font32up     {ASCII 32..81}
     else     _i= \font82up]    {ASCII 82..127}
    _j= _i 2<< _i+              {Multiply char code by 5}
    _j+ _j=                     {Add to page address to reach bitmap data}

    Pos \sysArgs4:              {Screen position for character}
    %-2=                        {Remember this position}
    6+ Pos=                     {Advance by 6 pixels}

    5 [do _i=                   {Draw character as 5 vertical bit slices}
      _j 0? \sysArgs2.          {Get bit slice as byte from ROM table}
      134!                      {SYS call to draw 8 pixels vertically}
      <_j++ <\sysArgs4++        {Advance to next byte}
      _i 1- if>0loop]           {Looping}

    %-2                         {Return position for backspace}
  ]

  ret
]

{-----------------------------------------------------------------------+
|       WozMon                                                          |
+-----------------------------------------------------------------------}

*=$ff00

_WozMon=*

{FF00} #$D8           { RESET:          CLD             Clear decimal arithmetic mode.          }
{FF01} #$58           {                 CLI                                                     }
{FF02} #$A0 #$7F      {                 LDY #$7F        Mask for DSP data direction register.   }
{FF04} #$2C #$12 #$D0 {         .BYTE   $2C,$12,$D0     [Gigatron] BIT DSP (was: STY DSP)       }
{FF07} #$A9 #$A7      {                 LDA #$A7        KBD and DSP control register mask.      }
{FF09} #$2C #$11 #$D0 {         .BYTE   $2C,$11,$D0     [Gigatron] BIT KBDCR (was: STA KBDCR)   }
{FF0C} #$2C #$13 #$D0 {         .BYTE   $2C,$13,$D0     [Gigatron] BIT DSPCR (was: STY DSPCR)   }
{FF0F} #$C9 #$DF      { NOTCR:          CMP #$DF        "<-"?                                   }
{FF11} #$F0 #$13      {                 BEQ BACKSPACE   Yes.                                    }
{FF13} #$C9 #$9B      {                 CMP #$9B        ESC?                                    }
{FF15} #$F0 #$03      {                 BEQ ESCAPE      Yes.                                    }
{FF17} #$C8           {                 INY             Advance text index.                     }
{FF18} #$10 #$0F      {                 BPL NEXTCHAR    Auto ESC if > 127.                      }
{FF1A} #$A9 #$DC      { ESCAPE:         LDA #$DC        "\".                                    }
{FF1C} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FF1F} #$A9 #$8D      { GETLINE:        LDA #$8D        CR.                                     }
{FF21} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FF24} #$A0 #$01      {                 LDY #$01        Initiallize text index.                 }
{FF26} #$88           { BACKSPACE:      DEY             Back up text index.                     }
{FF27} #$30 #$F6      {                 BMI GETLINE     Beyond start of line, reinitialize.     }
{FF29} #$A9 #$00      { NEXTCHAR:       LDA #$00        [Gigatron] A=0 to read keyboard.        }
{FF2B} #$00           {                 BRK             [Gigatron] Transfer to vCPU for input.  }
{FF2C} #$09 #$80      {                 ORA #$80        [Gigatron] B7 should be '1'.            }
{FF2E} #$2C #$10 #$D0 {         .BYTE   $2C,$10,$D0     [Gigatron] BIT KBD (was: LDA KBD)       }
{FF31} #$99 #$00 #$02 {                 STA IN,Y        Add to text buffer.                     }
{FF34} #$20 #$EF #$FF {                 JSR ECHO        Display character.                      }
{FF37} #$C9 #$8D      {                 CMP #$8D        CR?                                     }
{FF39} #$D0 #$D4      {                 BNE NOTCR       No.                                     }
{FF3B} #$A0 #$FF      {                 LDY #$FF        Reset text index.                       }
{FF3D} #$A9 #$00      {                 LDA #$00        For XAM mode.                           }
{FF3F} #$AA           {                 TAX             0->X.                                   }
{FF40} #$0A           { SETSTOR:        ASL             Leaves $7B if setting STOR mode.        }
{FF41} #$85 #$3B      { SETMODE:        STA MODE        $00 = XAM, $7B= STOR,$AE= BLOK XAM      }
{FF43} #$C8           { BLSKIP:         INY             Advance text index.                     }
{FF44} #$B9 #$00 #$02 { NEXTITEM:       LDA IN,Y        Get character.                          }
{FF47} #$C9 #$8D      {                 CMP #$8D        CR?                                     }
{FF49} #$F0 #$D4      {                 BEQ GETLINE     Yes, done this line.                    }
{FF4B} #$C9 #$AE      {                 CMP #$AE        "."?                                    }
{FF4D} #$90 #$F4      {                 BCC BLSKIP      Skip delimiter.                         }
{FF4F} #$F0 #$F0      {                 BEQ SETMODE     Yes, BLOCK XAM mode.                    }
{FF51} #$C9 #$BA      {                 CMP #$BA        ":"?                                    }
{FF53} #$F0 #$EB      {                 BEQ SETSTOR     Yes, set STOR mode.                     }
{FF55} #$C9 #$D2      {                 CMP #$D2        "R"?                                    }
{FF57} #$F0 #$3B      {                 BEQ RUN         Yes, run user program.                  }
{FF59} #$86 #$38      {                 STX L           $00->L.                                 }
{FF5B} #$86 #$39      {                 STX H            and H.                                 }
{FF5D} #$84 #$3A      {                 STY YSAV        Save Y for comparison.                  }
{FF5F} #$B9 #$00 #$02 { NEXTHEX:        LDA IN,Y        Get character for hex test.             }
{FF62} #$49 #$B0      {                 EOR #$B0        Map digits to $0-9.                     }
{FF64} #$C9 #$0A      {                 CMP #$0A        Digit?                                  }
{FF66} #$90 #$06      {                 BCC DIG         Yes.                                    }
{FF68} #$69 #$88      {                 ADC #$88        Map letter "A"-"F" to $FA-FF.           }
{FF6A} #$C9 #$FA      {                 CMP #$FA        Hex letter?                             }
{FF6C} #$90 #$11      {                 BCC NOTHEX      No, character not hex.                  }
{FF6E} #$0A           { DIG:            ASL                                                     }
{FF6F} #$0A           {                 ASL             Hex digit to MSD of A.                  }
{FF70} #$0A           {                 ASL                                                     }
{FF71} #$0A           {                 ASL                                                     }
{FF72} #$A2 #$04      {                 LDX #$04        Shift count.                            }
{FF74} #$0A           { HEXSHIFT:       ASL             Hex digit left, MSB to carry.           }
{FF75} #$26 #$38      {                 ROL L           Rotate into LSD.                        }
{FF77} #$26 #$39      {                 ROL H           Rotate into MSD's.                      }
{FF79} #$CA           {                 DEX             Done 4 shifts?                          }
{FF7A} #$D0 #$F8      {                 BNE HEXSHIFT    No, loop.                               }
{FF7C} #$C8           {                 INY             Advance text index.                     }
{FF7D} #$D0 #$E0      {                 BNE NEXTHEX     Always taken. Check next character for hex.}
{FF7F} #$C4 #$3A      { NOTHEX:         CPY YSAV        Check if L, H empty (no hex digits).    }
{FF81} #$F0 #$97      {                 BEQ ESCAPE      Yes, generate  ESC sequence.            }
{FF83} #$24 #$3B      {                 BIT MODE        Test MODE byte.                         }
{FF85} #$50 #$10      {                 BVC NOTSTOR     B6 = 0 for STOR, 1 for XAM and BLOCK XAM}
{FF87} #$A5 #$38      {                 LDA L           LSD's of hex data.                      }
{FF89} #$81 #$36      {                 STA (STL,X)     Store at current 'store index'.         }
{FF8B} #$E6 #$36      {                 INC STL         Increment store index.                  }
{FF8D} #$D0 #$B5      {                 BNE NEXTITEM    Get next item. (no carry).              }
{FF8F} #$E6 #$37      {                 INC STH         Add carry to 'store index' high order.  }
{FF91} #$4C #$44 #$FF { TONEXTITEM:     JMP NEXTITEM    Get next command item.                  }
{FF94} #$6C #$34 #$00 { RUN:            JMP (XAML)      Run at current XAM index.               }
{FF97} #$30 #$2B      { NOTSTOR:        BMI XAMNEXT     B7 = 0 for XAM, 1 for BLOCK XAM.        }
{FF99} #$A2 #$02      {                 LDX #$02        Byte count.                             }
{FF9B} #$B5 #$37      { SETADR:         LDA L-1,X       Copy hex data to                        }
{FF9D} #$95 #$35      {                 STA STL-1,X       'store index'.                        }
{FF9F} #$95 #$33      {                 STA XAML-1,X    And to 'XAM index'.                     }
{FFA1} #$CA           {                 DEX             Next of 2 bytes.                        }
{FFA2} #$D0 #$F7      {                 BNE SETADR      Loop unless X = 0.                      }
{FFA4} #$D0 #$14      { NXTPRNT:        BNE PRDATA      NE means no address to print.           }
{FFA6} #$A9 #$8D      {                 LDA #$8D        CR.                                     }
{FFA8} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FFAB} #$A5 #$35      {                 LDA XAMH        'Examine index' high-order byte.        }
{FFAD} #$20 #$DC #$FF {                 JSR PRBYTE      Output it in hex format.                }
{FFB0} #$A5 #$34      {                 LDA XAML        Low-order 'examine index' byte.         }
{FFB2} #$20 #$DC #$FF {                 JSR PRBYTE      Output it in hex format.                }
{FFB5} #$A9 #$BA      {                 LDA #$BA        ":".                                    }
{FFB7} #$20 #$EF #$FF {                 JSR ECHO        Output it.                              }
{FFBA} #$A9 #$04      { PRDATA:         LDA #$04        [Gigatron] 4 pixels wide blank.         }
{FFBC} #$20 #$F3 #$FF {                 JSR BLANK       [Gigatron] Output it.                   }
{FFBF} #$A1 #$34      {                 LDA (XAML,X)    Get data byte at 'examine index'.       }
{FFC1} #$20 #$DC #$FF {                 JSR PRBYTE      Output it in hex format.                }
{FFC4} #$86 #$3B      { XAMNEXT:        STX MODE        0->MODE (XAM mode).                     }
{FFC6} #$A5 #$34      {                 LDA XAML                                                }
{FFC8} #$C5 #$38      {                 CMP L           Compare 'examine index' to hex data.    }
{FFCA} #$A5 #$35      {                 LDA XAMH                                                }
{FFCC} #$E5 #$39      {                 SBC H                                                   }
{FFCE} #$B0 #$C1      {                 BCS TONEXTITEM  Not less, so no more data to output.    }
{FFD0} #$E6 #$34      {                 INC XAML                                                }
{FFD2} #$D0 #$02      {                 BNE MOD8CHK     Increment 'examine index'.              }
{FFD4} #$E6 #$35      {                 INC XAMH                                                }
{FFD6} #$A5 #$34      { MOD8CHK:        LDA XAML        Check low-order 'examine index' byte    }
{FFD8} #$29 #$07      {                 AND #$07          For MOD 8= 0                          }
{FFDA} #$10 #$C8      {                 BPL NXTPRNT     Always taken.                           }
{FFDC} #$48           { PRBYTE:         PHA             Save A for LSD.                         }
{FFDD} #$4A           {                 LSR                                                     }
{FFDE} #$4A           {                 LSR                                                     }
{FFDF} #$4A           {                 LSR             MSD to LSD position.                    }
{FFE0} #$4A           {                 LSR                                                     }
{FFE1} #$20 #$E5 #$FF {                 JSR PRHEX       Output hex digit.                       }
{FFE4} #$68           {                 PLA             Restore A.                              }
{FFE5} #$29 #$0F      { PRHEX:          AND #$0F        Mask LSD for hex print.                 }
{FFE7} #$09 #$B0      {                 ORA #$B0        Add "0".                                }
{FFE9} #$C9 #$BA      {                 CMP #$BA        Digit?                                  }
{FFEB} #$90 #$02      {                 BCC ECHO        Yes, output it.                         }
{FFED} #$69 #$06      {                 ADC #$06        Add offset for letter.                  }
{FFEF} #$48           { ECHO:           PHA             [Gigatron]                              }
{FFF0} #$00           {                 BRK             [Gigatron] Transfer to vCPU for display.}
{FFF1} #$68           {                 PLA             [Gigatron]                              }
{FFF2} #$60           {                 RTS             [Gigatron] Return.                      }
{FFF3} #$18           { BLANK:          CLC             [Gigatron] Advance few pixels so BLOCK  }
{FFF4} #$65 #$30      {                 ADC $30         [Gigatron]   XAM doesn't wrap around    }
{FFF6} #$85 #$30      {                 STA $30         [Gigatron]   the 160 pixel wide screen. }
{FFF8} #$60           {                 RTS             [Gigatron]                              }
{FFF9} #$00           { (unused)                                                                }
{FFFA} #$00 #$00      { (NMI)                                                                   }
{FFFC} #$00 #$FF      { (RESET)                                                                 }
{FFFE} #$00 #$00      { (IRQ)                                                                   }

{-----------------------------------------------------------------------+
|                                                                       |
+-----------------------------------------------------------------------}

