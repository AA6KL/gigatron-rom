
{-----------------------------------------------------------------------+
|                                                                       |
|       Command.gcl                                                     |
|                                                                       |
|       !!! Work in progress !!!                                        |
|                                                                       |
|       - Prompt with command line input                                |
|       - Load GT1 command file into RAM                                |
|       - Run command                                                   |
|       - Error reporting                                               |
|                                                                       |
+-----------------------------------------------------------------------}
gcl0x

{-----------------------------------------------------------------------+
|                                                                       |
|       Variables                                                       |
|                                                                       |
+-----------------------------------------------------------------------}

_r0=$30                         {First 16 bytes act as register set}
_r1=$32
_r2=$34
_r3=$36
_r4=$38
_r5=$3a
_r6=$3c
_r7=$3e

zpReset=$40                     {Start GCL vars from $40 instead of $30}

_StdOut=$300
_OpenFile=$400

{-----------------------------------------------------------------------+
|                                                                       |
|       Command.gt1 bootstrapping                                       |
|                                                                       |
+-----------------------------------------------------------------------}

{
  It is System.gt1's job to load Command.gt1 into RAM. However, GT1 decoding
  functionality is part of Command.gt1, not System.gt1... So we have a boot
  strapping process to make it possible: System.gt1 only loads Command's first
  sector and then transfers control. From there System.gt1 must decode itself
  and load its remainder into RAM. The start address is $0503 so that after
  loading the first sectore the boot strapping code is already in the right
  spot, ready to take over.
}

*=$0503
[
  [do loop]                     {XXX Work in progress}

  { XXX: Check for presence of System.gcl }
  { XXX: Set top of memory }

  \CommandLoop!
]

{-----------------------------------------------------------------------+
|} >_vLR++ [ret] {      RAM page $7f                                    |
+-----------------------------------------------------------------------}
*=$7fa0

{-----------------------------------------------------------------------+
|                                                                       |
|       Main program                                                    |
|                                                                       |
+-----------------------------------------------------------------------}

_CommandLoop=*
[do
  { XXX: Print newline if needed }

  { XXX: Print error message if needed }

  { XXX: Clear error state }

  { XXX: Print prompt }

  _Prompt!

  { XXX: Read line from stdin in $500, edit with DEL }

  _ReadLine!

  { XXX: Find file.GT1 on A: }

  { XXX: Load first sector }

  { XXX: If first segment is $503 }

  { XXX: then load with own loader }

  { XXX: else load with another loader }

  { XXX: and execute }

  loop]

{-----------------------------------------------------------------------+
|                       RAM page $7e                                    |
+-----------------------------------------------------------------------}
*=$7ea0

_Prompt=*
[
  $3e _StdOut!                  {'>'}
  ret
]

{-----------------------------------------------------------------------+
|                       RAM page $7d                                    |
+-----------------------------------------------------------------------}
*=$7da0

_ReadLine=*
[
  ret
]

{-----------------------------------------------------------------------+
|                       RAM page $7c                                    |
+-----------------------------------------------------------------------}
*=$7ca0

_WaitKey=*
[
  ret
]

{-----------------------------------------------------------------------+
|                       RAM page $7b                                    |
+-----------------------------------------------------------------------}
*=$7ba0

_PrintResult=*
[
  {
    Print OK or FAILED
  }
  push
  k=                            {Preserve vAC for caller}
  [if=0
    [def ``OK #10 #0]
  else
    [def ``FAILED #10 #0]
  ] \PrintText!
  k
  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $7a                                    |
+-----------------------------------------------------------------------}
*=$7aa0

{ PrintText -- writes q }
_PrintText=*
[
  {
    Print text string, may include newline characters (#10)
    Returns 0
  }
  push                          {Save vLR because this is not a leaf subroutine}
  q=
  [do                           {Loop over characters}
    q, if<>0                    {Next character to be printed, unless 0}
    _StdOut!                    {Send to terminal}
    <q++ loop]                  {Advance text pointer and loop}
  pop ret
]

{-----------------------------------------------------------------------+
|                                                                       |
|       File reading section                                            |
|                                                                       |
+-----------------------------------------------------------------------}

{-----------------------------------------------------------------------+
|                       RAM page $79                                    |
+-----------------------------------------------------------------------}
*=$79a0

_LoadGt1=*
[
  {
    Load GT1 file into RAM and store start address in Address.
    See Docs/GT1-files.txt for details on GT1
    XXX Support loading into audio channels
  }
  push

  \OpenFile!                    {Prepare for reading}

  { Read file contents byte by byte }
  \LoadByte!                    {Fetch first byte}

  [do                           {Chunk copy loop}
    >Address.                   {High-address comes first}
    \LoadByte! <Address.        {Then the low address}
    \LoadByte!                  {Byte count (0 means 256)}
    [do                         {Byte copy loop}
      \sysArgs5.                {Implicitly chops counter to 8 bits}
      \LoadByte! Address.       {Poke next byte into memory}
      <Address++                {Advance write pointer in page}
      \sysArgs5, 1-             {Decrement counter}
      if<>0loop]
    \LoadByte!                  {Go to next block}
    if<>0loop]
  \LoadByte! >Address.          {Load execution address}
  \LoadByte! <Address.

  \LoadByte! [if>=0 0 Address=] {Expect EOF, clear Address when missing}

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $78                                    |
+-----------------------------------------------------------------------}
*=$78a0

_Execute=*
[

  120 [do i=                    {Restore video table}
    i+ $fe+ p=
    i 7+ p. 8- if>0loop]

  Address
  [do if=0loop]                 {Stop if not executable}
  call                          {Run...}
]

{-----------------------------------------------------------------------+
|                       RAM page $77                                    |
+-----------------------------------------------------------------------}
*=$77a0

_LoadByte=*
[
  ret
]

{-----------------------------------------------------------------------+
|                                                                       |
+-----------------------------------------------------------------------}
