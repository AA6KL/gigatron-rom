
{-----------------------------------------------------------------------+
|                                                                       |
|       GTOS                                                            |
|                                                                       |
|       !!! Work in progress !!!                                        |
|                                                                       |
|       Goal is to provide basic operating system services              |
|       - Terminal                                                      |
|       - Card access                                                   |
|       - Extensibility                                                 |
|                                                                       |
+-----------------------------------------------------------------------}
gcl0x

{
  XXX  Namespace. Shall we have device letters, or a Unix-like
       namespace (/dev/...) and/or file descriptors or libc style
       FILE*?
       Answer: GTOS will have "drive letters" that are actually
       a single hexnum, 0..9A-F (16 files is enough for everybody)
        0: stdin
        1: stdout
        2: stderr
        3..9: active files/streams/resources
        A: SPI0 a.k.a. SD card 0
        B: SPI1
        C: SPI2
        D: SPI3
        E: ...      (/dev/null? E for "Empty")
        F: ROM disk (F for "Fixed")
  XXX Positive card detection:
        Read MISO's
        Invert
        Write to ZP
        Read MISO
  XXX  https://cdn.hackaday.io/images/1744261554112919559.png
  XXX  SYS extension for copying to and from object variables
  XXX  LoadtGt1: proper closing of last sector
  XXX  Compliancy: Byte addressing for V2 cards when CCS bit in CMD58 OCR is 0
  XXX  Compliancy: MMC v3 card detection with CMD1
  XXX  Compliancy: Don't set block size with CMD16 if CCS bit in OCS is 1
  XXX  Compliancy: Reconsider pull-down resistors on MISO lines
                   Some cards [30%?] [MMC?] have MISO in open collector during
                   init" But if this is only during CMD0, we can live with it...
  XXX  Compliancy: Follow cluster chain for directories as well
  XXX  Speed: Transfer 256 bytes at once
  XXX  Think about card detect and monitoring it (inserted = low)
       Put we can always use the MOSI line for this, or check the
       init status when opening a file
  XXX  Figure out why Apple formats card with type 0x0b
  XXX  Check CardType, reject byte addressing
}

{-----------------------------------------------------------------------+
|                                                                       |
|       Variables                                                       |
|                                                                       |
+-----------------------------------------------------------------------}

_r0=$30                         {First 16 bytes act as register set}
_r1=$32
_r2=$34
_r3=$36
_r4=$38
_r5=$3a
_r6=$3c
_r7=$3e

zpReset=$40                     {Start GCL vars from $40 instead of $30}

_TermOut=$300
_OpenFile=$400

_Buffer=$500                    {General purpose 512-byte buffer}

{
        XXX These must move into and object
        Variable        Bytes   Description
        --------        -----   -----------
        ClusterBaseL,H  ----    Cluster origin (hypothetical cluster 0)
        FatBaseL,H      ----    XXX
        ValueL,H        XXXX    32-bit accumulator
        OffsetL,H       XXXX    Offset to be added to ValueL,H
        SectorL,H       XXXX    Block number of last sector
        CurrentDirL,H   ----    First cluster of current directory
        ClusterSize     X       Sectors per cluster: 1, 2, ... 128
        ClusterMask     X       XXX ClusterSize - 1

        FileSizeL,H     ????    File size from directory entry
        FilePosL,H      --XX    Current R/W position in file: 0..FileSize

        Memory usage
        ------------
        $500  $6ff              Buffer for reading FAT sectors
        $58a0 $xxff             Code not needed for GT1 reading
                                Eg. detecting the card settings
        $xxa0 $78ff             GT1 reading core
        $7fa0 ...               Cluster list
}

{-----------------------------------------------------------------------+
|                       RAM page 2                                      |
+-----------------------------------------------------------------------}
*=$200

[
  \romType, \romTypeValue_DEVROM-
  [if<0                         {Version mismatch}
    [def                        {Give error using just ROM v1 features}
      _r0= [do _r0,             {Fetch next char}
        [do if=0loop]           {Loop forever at end of message}
        \TermOut! <_r0++ loop]  {Print char and continue}
    ] _r0=
    [def #10 `Need`DEVROM #0] _r0!
  ]

  [def #10 `GTOS`DEV`32K #0] _r0=
  [do _r0, if<>0 \TermOut! <_r0++ loop]

  [do loop]                     { XXX Work in progress }

  \InitFat32!                   {Prepare reading FAT32 structures}
  \ReadDirectory!               {Read root directory}
]

_InitFat32=*
[
  push

  \ReadMBR!                     {Master Boot Record}
  [if=0 \ReadVolumeId!]         {Read first block of FAT partition}

  {
    Calculate cluster base and set current directory to root

        ClusterBaseL,H =
                PartitionL,H                    from MBR
              + Reserved Sectors                from VolumeId
              + (Number of FATs * FAT size)     from VolumeId
              - 2 * ClusterSize                 from VolumeId
  }

  $50d peek                     {Sectors per cluster}
  ClusterSize=

  SectorL ValueL=               {Partition's first sector, from MBR}
  SectorH ValueH=

  $50e deek OffsetL=            {Number of reserved sectors}
  0 OffsetH=
  \AddOffset!

  FatBaseL=
  ValueH FatBaseH=              {Begin of primary FAT area}

  $524 deek OffsetL=            {FAT size in sectors}
  $526 deek OffsetH=
  \AddOffset! \AddOffset!       {Number of FATs is always 2}

  0 ClusterSize- ClusterSize-   {Subtract twice to arrive at ClusterBase}
  OffsetL=
  $ffff OffsetH=
  \AddOffset!

         ClusterBaseL=
  ValueH ClusterBaseH=

  { First cluster of root directory }
  $52c deek CurrentDirL=
  $52e deek CurrentDirH=

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page 3                                      |
+-----------------------------------------------------------------------}
*=$300

{-----------------------------------------------------------------------+
|                                                                       |
|       Video terminal section                                          |
|                                                                       |
+-----------------------------------------------------------------------}

{ Closure for writing to video terminal }
_TermOut=*
[
  { Function }
  push \CharOut!
  { Variables }
  ##0                           {Pos}
]

{ CharOut -- writes i j _sysFn _sysArgs[01245] }

_CharOut=*
[
  %-2=                          {Park character in stack area}

  10^ [if<>0                    {Test for CR}
    _vLR, 155- if>0 0]          { or line wrap}
  [if=0

    { Clear new line first }
    $3f20 _sysArgs0=            {White on blue}
    $11f deek 255| 255^ _vLR:   {Go to start of next line}
    _sysArgs4=                  {Set screen position}
    \sysArgs2.                  {Set all-zero output pattern}
    [do
      \SYS_VDrawBits_134        {SYS call to draw 8 pixels vertically}
      _sysFn= 134!!
      <_sysArgs4++              {Step 1 pixel right}
      \sysArgs4, 160^           {Test for end of line}
      if<>0loop]

    { Then scroll up by modifying videoTable }
    $01 >i. 208                 {Last entry at $100+238, minus 30}
    [do
      30+ <i.
      i, 120- [if<0 128+
               else 24+] i.     {Rotate by 8 in 24..127 range}
      <i, 32- if>0loop]         {Move to previous entry in video table}
  ]

  { Draw ASCII character (>=32) on screen using the 5x8 pixel built-in font }
  %-2 32-

{ XXX TODO
  32- [if<0 127 else 96-        {Map any non-ASCII to block symbol 127}
       if>=0 127] 127& }

  [if>=0
    50-                         {Map ASCII code to offset in font table}
    [if<0 50+ i= &_font32up     {First page for ASCII 32..81}
     else     i= &_font82up] j= {Second page is ASCII 82..127}
    i 2<< i+                    {Multiply by 5}
    j+ j=                       {Add page address to reach bitmap data}
    $3f20 _sysArgs0=            {White on blue}
    _vLR; _sysArgs4=            {Position of character}
    6+ _vLR:                    {Advance position by 6 pixels for next call}
    \SYS_VDrawBits_134 _sysFn=  {Prepare SYS calls}
    5 [do i=                    {Loop to draw 5 vertical slices of 8 pixels}
      j 0? \sysArgs2.           {Get byte from ROM using `LUP 0' instruction}
      134!!                     {Invoke SYS function to draw 8 vertical pixels}
      <j++ <_sysArgs4++         {Advance to next slice in ROM and on screen}
      i 1- if>0loop]            {Looping}
  ]

  pop ret                       {Closure return}
]

{-----------------------------------------------------------------------+
|                       RAM page 4                                      |
+-----------------------------------------------------------------------}
*=$400

_OpenFile=*
[
  {
    Prepare for reading file whose directory entry is pointed at by p
  }
  push
  0 FilePosL= FilePosH=         {Reset position in file}
  p $1c+ deek FileSizeL=        {Length of file in bytes}
  p $1e+ deek FileSizeH=
  p $1a+ deek ValueL=           {First cluster for file}
  p $14+ deek ValueH=
  \ReadClusterChain!
  \ClusterToSector!
  pop ret
]

{-----------------------------------------------------------------------+
|                                                                       |
|       Memory card section                                             |
|                                                                       |
+-----------------------------------------------------------------------}

{-----------------------------------------------------------------------+
|                       RAM page $5c                                    |
+-----------------------------------------------------------------------}
*=$5ca0

_CMD17=*
[
  {
    CMD17 READ_SINGLE_BLOCK
    Reads a block of the size selected by the SET_BLOCKLEN command
  }
  push

  [def #$51 #0 #0 #0 #0 #0]     {CMD17}
  p= q=
  >SectorH, <q++ q.             {Put SectorL,H in argument, big-endian order}
  <SectorH, <q++ q.
  >SectorL, <q++ q.
  <SectorL, <q++ q.
  p \SendCommandToCard!

  \WaitForCardReply!
  254&                          {Only 0 and 1 mean success}

  [if=0
    {Wait for first data byte}
    [do
      \SendOnesToCard!          {XXX Can we use WaitForCardReply here?}
      $ff^ if=0loop]            {XXX Loop needs a timeout}
      {\sysArgs6, $fe^          {Only $fe is OK}}
  ]

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $5d                                    |
+-----------------------------------------------------------------------}
*=$5da0

{
        Bus     ROM v4+
        ---     --------
        A0      SCLK
        A1      (unused)
        A2      /SS0
        A3      /SS1
        A4      /SS2
        A5      /SS3
        A6      B0
        A7      B1
        A8-A14  (unused)
        A15     MOSI
}

_EnableCard=*
[
  \SYS_ExpanderControl_v4_40    {SYS function}
  _sysFn= $8078 40!!            {Enable SPI0, keep MOSI high, bank=1}
  ret
]

_DisableCard=*
[
  \SYS_ExpanderControl_v4_40    {SYS function}
  _sysFn= $807c 40!!            {Disable SPI0, keep MOSI high, bank=1}
  ret
]

_SendOnesToCard=*
[
  255 \sysArgs6.                {Place byte in exchange buffer}
  \sysArgs6 _sysArgs0=          {Begin}
  1+        _sysArgs2=          {End}
  \SYS_SpiExchangeBytes_v4_134  {SYS function}
  _sysFn= 134!!                 {Exchanges a single byte}
  \sysArgs6,                    {Reply byte}
  ret
]

{-----------------------------------------------------------------------+
|                       RAM page $5e                                    |
+-----------------------------------------------------------------------}
*=$5ea0

{-----------------------------------------------------------------------+
|                       RAM page $5f                                    |
+-----------------------------------------------------------------------}
*=$5fa0

_SendCommandToCard=*
[
  push

  { Setup command bytes }
  p= \Buffer q=
  255 q. <q++ q. <q++           {Start with two dummy bytes}
  6 [do i=                      {Copy 6 command bytes to exchange buffer}
    p, <p++                     {Fetch byte and advance read pointer}
    q. <q++                     {Store byte and advance write pointer}
    i 1- if>0loop]              {Looping}

  { Send to SPI device }
  \Buffer _sysArgs0=            {Begin}
  8+      _sysArgs2=            {End and overwrite exchange buffer}
  \SYS_SpiExchangeBytes_v4_134  {SYS function}
  _sysFn= 134!!

  pop ret
]

_WaitForCardReply=*
[
  push
  {
  |  """To receive this message, your program should continuously toggle
  |     the SD CLK signal and observe the MISO line for data, while keeping
  |     the MOSI line high and the CS line low. Your program can detect the
  |     message, because every message begins with a 0 bit, and when the
  |     SD card sends no data it keeps the MISO line high."""
  |
  |  """Note that the response to each command is sent by the card a few
  |     SD CLK cycles later. If the expected response is not received within
  |     16 clock cycles after sending the reset command, the reset command
  |     has to be sent again."""
  }
  8 [do i=                      {Poll for upto 8 reply bytes}
    \SendOnesToCard!            {Keep MOSI line high by only sending ones}
    128&                        {Note: communication is byte-aligned}
    if<>0                       {Break out when valid message detected}
      i 1- if>0loop]            {Or when loop counter exhausted}

  {32 p!                        {Space}}
  \sysArgs6, CardReply=         {Store reply from card}
  CardReply                     {As return value}
  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $60                                    |
+-----------------------------------------------------------------------}
*=$60a0

{-----------------------------------------------------------------------+
|                                                                       |
|       FAT32 section                                                   |
|                                                                       |
+-----------------------------------------------------------------------}

_ReadVolumeId=*
[
  {
    Reads the first block of the partition. Mind that, despite it's name,
    this block doesn't hold the volume label: that is stored in the root
    directory instead.
  }
  push

  \ReadSector!                  {SectorL,H as set by ReadMBR}

  \Buffer $b+ deek k=           {Confirm expected sector length}
  $200 k^                       {Only $200 is ok}

  pop ret
]

_ReadMBR=*
[
  {
     Reads MBR and finds the primary partition's start block
     Check if it is FAT32
  }
  push

  0 SectorL= SectorH=           {First sector on device}
  \ReadSector!                  {Read MBR}

  $6fe deek k=                  {Fetch signature}
  $aa55 k^                      {Check signature}

  [if=0
    $6c6 deek SectorL=          {Primary partition's first sector on disk}
    $6c8 deek SectorH=

    $6c2 peek k=                {Filesystem type code}
    $0b k^ [if<>0 $07^]         {Accepts $0b and $0c}
                                {XXX In case of $0b: check for CHS vs LBA ???}
  ]

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $62                                    |
+-----------------------------------------------------------------------}
*=$62a0

{-----------------------------------------------------------------------+
|                       RAM page $63                                    |
+-----------------------------------------------------------------------}
*=$63a0

_OpenSector=*
[
  {
    Tell card to read sector, but don't process the data yet
  }
  push

  \EnableCard!

  \CMD17!                       {Request block of data}

  pop ret
]

_ReadSector=*
[
  {
    Read sector from card into memory (clobbers ValueL,H and OffsetL,H)
  }
  push

  \OpenSector!                  {Start data stream}

  \Buffer q=                    {Setup write pointer}
  512 [do k=                    {Number of bytes to read}
    \SendOnesToCard!            {XXX Read directly into buffer}
    q.                          {Store byte in buffer}
    q 1+ q=                     {Advance write pointer, cross page boundaries}
    k 1- if>0loop]              {Looping}

  \SendOnesToCard!              {Read 16-bit checksum}
  \SendOnesToCard!
  \DisableCard!

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $64                                    |
+-----------------------------------------------------------------------}
*=$64a0

_LoadByte=*
[
  {
    Read next byte directly from file and advance position
    !!! XXX This is slow, but doesn't use buffer space !!!
  }
  push

  FilePosL FileSizeL^           {Check for EOF}
  [if=0 FilePosH FileSizeH^]

  [if<>0                        {More to read}

    $1ff FilePosL&              {Read new sector}
    [if=0
      \SendOnesToCard!          {Ignore checksum}
      \SendOnesToCard!
      \OpenSector!              {Open next sector}
      \NextSector!]

    FilePosL 1+ FilePosL=       {Increment position in file}
    [if=0 FilePosH 1+ FilePosH=]

    \SendOnesToCard!            {Returns the next data byte}
  else
    1-                          {Negative value for EOF}
  ]

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $65                                    |
+-----------------------------------------------------------------------}
*=$65a0

_ReadDirectory=*
[
  {
    Read first sector of current directory
  }
  push

  { Sector = ClusterBase + CurrentDir * ClusterSize }
  CurrentDirL ValueL=
  CurrentDirH ValueH=
  \ClusterToSector!
  \ReadSector!
  <SectorL++                    {XXX Replace with ClusterList}

  pop ret
]

{-----------------------------------------------------------------------+
|                                                                       |
|       32-bit arithmetic section                                       |
|                                                                       |
+-----------------------------------------------------------------------}

_ClusterToSector=*
[
  {
    Multiply ValueL,H by ClusterSize and add ClusterBase (clobbers OffsetL,H)
  }
  push
  >ValueH, 15& >ValueH.         {Clear the top 4 reserved bits}
  1 [do k=
    ClusterSize- if<0
    \ShiftLeft!
    k k+ loop]

  ClusterBaseL OffsetL=
  ClusterBaseH OffsetH=
  \AddOffset!

  ValueL SectorL=               {Set as next sector to read}
  ValueH SectorH=

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $66                                    |
+-----------------------------------------------------------------------}
*=$66a0

_ShiftLeft=*
[
  {
    Shift left ValueL,H by 1 bit (clobbers OffsetL,H)
  }
  push
  ValueL OffsetL=               {Double value}
  ValueH OffsetH=
  \AddOffset!
  OffsetH                       {Return old high word}
  pop ret
]

_AddOffset=*
[
  {
    Add 32-bit OffsetL,H to 32-bit ValueL,H and store result there
  }
  ValueL OffsetL^ [if<0         {Compare lower halves' most significant bits}
    ValueL                      {MSB unequal: carry taken from their sum}
  else
    $8000                       {MSB equal: carry taken from either term}
  ] OffsetL+                    {Carry now in MSB of vAC (inverted)}
  [if>=0 ValueH 1+ ValueH=]     {Apply carry to upper half}
  ValueH OffsetH+ ValueH=       {Sum upper half}
  ValueL OffsetL+ ValueL=       {Sum lower half and return this as well}
  ret
]

{-----------------------------------------------------------------------+
|                                                                       |
|       File reading section                                            |
|                                                                       |
+-----------------------------------------------------------------------}

{-----------------------------------------------------------------------+
|                       RAM page $75                                    |
+-----------------------------------------------------------------------}
*=$75a0

{*** some FAT functions ***}

_NextSector=*
[def
  push

  <SectorL++                    {To next sector}

  $1fff FileSizeL&              {XXX Hardcoded. Should derive from ClusterSize}
  [if=0
    List 4+ List= deek ValueL=  {Get next cluster from ClusterList}
    List 2+       deek ValueH=
    \ClusterToSector!
  ]

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $76                                    |
+-----------------------------------------------------------------------}
*=$76a0

_ReadClusterChain=*
[def
  {
    Traverse the FAT and collect the clusters used by this file
    XXX TODO Don't do this if the file is smaller than the cluster size
  }
  push

  \ClusterList List=            {Reset}
  [do
    { Store in list }
    ValueL List: <List++ <List++
    ValueH List: <List++ <List++

    { Break at End Of Cluster marker }
    $f000 ValueH| 1+ [if=0      {Test high word first, ignore bit 28:31}
    $0007 ValueL| 1+] if<>0     {Optionally test low word, ignore bit 0:2}

    \NextCluster!
    loop]

  \ClusterList                  {Reset}
  List=   deek ValueL=
  List 2+ deek ValueH=

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $77                                    |
+-----------------------------------------------------------------------}
*=$77a0

_NextCluster=*
[
  {
    Find next cluster in FAT
  }
  push

  >ValueL, <OffsetL.            {Offset = Cluster >> 8}
  <ValueH, >OffsetL.
  >ValueH,  OffsetH=

  <ValueL, m=                   {Park the lowest 8 bits in m}
  128& peek ValueL=             {Value = 1 if bit7 else 0}
  0         ValueH=
  \AddOffset! \AddOffset!       {Value += 2 * Offset: now we have Cluster >> 7}

  FatBaseL OffsetL=             {Value += First sector for FAT}
  FatBaseH OffsetH=
  \AddOffset!

  SectorL^                      {Compare sector number to what we already have}
  [if=0 ValueH SectorH^]

  [if<>0
    ValueL SectorL=             {Read new sector from FAT area}
    ValueH SectorH=
    \ReadSector!
  ]

  m 127& 2<< m=                 {Index in FAT sector at 32-bit word i & $7f}
  $500 m+ deek ValueL=          {Fetch next cluster number in the chain}
  $502 m+ deek ValueH=

  pop ret
]

{-----------------------------------------------------------------------+
|                       RAM page $7f                                    |
+-----------------------------------------------------------------------}

_ClusterList=$7fa0              {Room for 96/4 = 24 clusters}

{-----------------------------------------------------------------------+
|                                                                       |
+-----------------------------------------------------------------------}

