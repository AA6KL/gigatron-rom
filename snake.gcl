
{-----------------------------------------------------------------------+
|                                                                       |
|       GCL applications                                                |
|                                                                       |
+-----------------------------------------------------------------------}

{
Gigatron RAM map
----------------
             +------------------------------------+---------------------+
page 0       | System and program variables     <-|-> vCPU stack at top |
             +------------------------------------+--+------------------+
page 1       | Video frame indirection table         | Channel 1 at top |
             +---------------------------------------+------------------+
page 2       | Shift table for sound                 | Channel 2 at top |
             +---------------------------------------+------------------+
page 3       | vCPU code                          248| Channel 3 at top |
             |                                       +------------------+
page 4       |                                       | Channel 4 at top |
             |                                       +------------------+
page 5-7     |0                       159 160                        255|
             +---------------------------+------------------------------+
page 8-127   | 120 lines of 160 pixels   | Extra video/code/data at top |
             +---------------------------+------------------------------+
page 128-255 | Not used in the 32K system: mirror of page 0-127         |
             +----------------------------------------------------------+
}

{-----------------------------------------------------------------------+
|                       RAM page 3                                      |
+-----------------------------------------------------------------------}
$0300:

{-
  First setup all subroutine definitions and variables, without making
  calls. This way allows use of vRT to hop from page to page during setup,
  with minimal overhead. At the end, run the main loop.
-}

[def
{-
  DrawChar(Char)

  Draw a 5x8 character on screen with the built-in font.
  `Char' must be in the 32-127 range (this is not checked)
-}
  {Map ASCII code to offset in font table}
  Char 82- [if<0 50+ i= \font32up
            else     i= \font82up] fontData= {Select low or high page}
  i i+ tmp= tmp+ i+    {Multiply by 5}
  fontData+ fontData=  {Add to page address to reach bitmap data for Char}
  $800 Pos+ q=         {Where to stop the inner drawing loop}

  {Draw 6 vertical slices: 5 using font data, the last with all-zeros}
  5 i= [do
    [if<>0 fontData 0; fontData<++ else 0] bits=
    Pos p=
    {Draw vertical slice}
    [do
      bits 128& [if=0 0 {Black} else Color] p!
      bits bits+ bits=
      p>++
      p q- if<0loop]
    Pos<++
    i 1- i= if>=0loop]
  ret
] DrawChar=

[def
{-
  DrawText(Text,Pos)

  Draw a zero-terminated text string to the screen.
  Character 10 acts as newline.
  There is no check for running off screen.
-}
  push
  [do
    Text? Char= {Next character to be printed}
    if<>0       {Zero termination}
      Text<++   {Advance text pointer}
      Char 10^ [if=0 Pos<! $800 Pos+ Pos=
                else DrawChar call]
      loop]
  pop call
] DrawText=

[def
{-
  Startup message
-}
  {XXX move this to a ROM table}
  {XXX display the counted memory}
  {XXX Make ROM version readable by applications}
  {XXX display number of free bytes}
  {   *** Gigatron 32K ***    }
  $20. $20. $20. $2a. $2a. $2a. $20. $47. $69. $67. $61. $74. $72. $6f. $6e.
  $20. $33. $32. $4b. $20. $2a. $2a. $2a. $20. $20. $20. $20. 10.
  {TTL color computer ROM v0  }
  $54. $54. $4c. $20. $63. $6f. $6c. $6f. $72. $20. $63. $6f. $6d. $70. $75.
  $74. $65. $72. $20. $52. $4f. $4d. $20. $76. $30. $20. $20. 10. 0.
] Welcome=

[def
{-
  DrawLine -- Draw line
-}
  Count i=
  [do if>0
    Color Pos!
    Pos Step+ Pos=
    i 1- i=
    loop]
  ret
] DrawLine=

{-----------------------------------------------------------------------+
|}ret{                  RAM page 4                                      |
+-----------------------------------------------------------------------}
$0400:

[def
{-
  Wait -- Wait Delay number of frames (range 1..255)
-}
  \frameCount? Delay+ 255& tmp=
  [do \frameCount? tmp- if<>0loop]
  ret
] Wait=

[def
{-
  Intro
-}
  push

  {Display welcome tekst}
  8 {Green} Color=
  $800 Pos=
  Welcome Text=
  DrawText call

  ClearScreen call

  {Wait for sound to stop}
  [do \soundTimer? if<>0loop]

  60 Delay= Wait call

  pop call
] Intro=

[def
{-
  ClearScreen -- Clear screen from current position to bottom right
-}
  Pos p=
  Pos 255| 255-         {XXX Is there a better way to clear the low byte?}
  i= $8001 i+ i=        {Offset to move to next stripe}
  [do
    {Clear one stripe}
    p [do
      {p} \sysArgs= \SYS_38_VCLEAR8 38@ {Clears 8 pixels vertically}
      $800 p+ p= if>0loop]
    {Next stripe}
    i+ p=
    255& 160^ if<>0loop]
  ret
] ClearScreen=

[def
{-
  Setup game
-}
  push

  {ClearScreen}
  $1000 Pos= ClearScreen call

  {Draw bounding box}
  8 {Green} Color=
  $1000 Pos=
     +1 Step= 159 Count= DrawLine call
   $100 Step= 111 Count= DrawLine call
     -1 Step= 159 Count= DrawLine call
  -$100 Step= 111 Count= DrawLine call
  pop call
] SetupGame=

[def
{-
  Game over
-}
  push
  $4034 Pos=
  [def
    $47. $41. $4d. $45. $20. $4f. $56. $45. $52. 0. {GAME OVER}
  ] Text=
  DrawText call
  pop call
] GameOver=

{-----------------------------------------------------------------------+
|}\vRT>++ ret{          RAM page 5                                      |
+-----------------------------------------------------------------------}
$0500:

[def
  0 stepV- tmp=
  stepU stepV=
  tmp   stepU=
  ret
] TurnL=

[def
  0 stepU- tmp=
  stepV stepU=
  tmp   stepV=
  ret
] TurnR=


[def
{-
  RunGame --
-}
  push

  {Place snake}
  $3050 Head=
  10 {Yellow} Color=
     1 stepU=
  $100 stepV=
  3 Delay= {Speed}

  [do
    {Auto snake control}

    10 {Yellow} Head!

    {Look left}  Head stepV- peek [if=0 TurnL else 0] p=
    {Look right} Head stepV+ peek [if=0 TurnR else 0] q=
    {Look ahead} Head stepU+ peek [if=0 \entropy? $7f& 3- [if<0 1 else 0]]
    [if<>0
      {Wall or random direction change: must go left or right.
       Pick randomly, without bias, but don't crash into a wall when not needed}
      p [if=0 q else
        q [if=0 p else
         \entropy? 1& [if=0 p else q]
        ]
      ]
      [if<>0 call]
    ]

    Head stepU+ Head=
    Head? if=0
      15 {Bright Yellow} Head!
      Wait call
      loop]

  3 {Bright Red} Color= Head!

  pop call
] RunGame=

{-----------------------------------------------------------------------+
|}\vRT>++ ret{          RAM page 6                                      |
+-----------------------------------------------------------------------}
$0600:

{--- Run ---}

Intro call

[do
  SetupGame call

  RunGame call

  GameOver call

  240 Delay= Wait call

  loop]

{-----------------------------------------------------------------------+
|       End                                                             |
+-----------------------------------------------------------------------}

